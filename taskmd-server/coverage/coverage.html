
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tktomaru/taskai/taskai-server/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/tktomaru/taskai/taskai-server/internal/api/auth_handlers.go (0.0%)</option>
				
				<option value="file2">github.com/tktomaru/taskai/taskai-server/internal/api/middleware.go (0.0%)</option>
				
				<option value="file3">github.com/tktomaru/taskai/taskai-server/internal/api/project_handlers.go (0.0%)</option>
				
				<option value="file4">github.com/tktomaru/taskai/taskai-server/internal/api/revision_handlers.go (0.0%)</option>
				
				<option value="file5">github.com/tktomaru/taskai/taskai-server/internal/api/router.go (0.0%)</option>
				
				<option value="file6">github.com/tktomaru/taskai/taskai-server/internal/api/search_handlers.go (0.0%)</option>
				
				<option value="file7">github.com/tktomaru/taskai/taskai-server/internal/api/task_handlers.go (0.0%)</option>
				
				<option value="file8">github.com/tktomaru/taskai/taskai-server/internal/api/view_handlers.go (0.0%)</option>
				
				<option value="file9">github.com/tktomaru/taskai/taskai-server/internal/api/websocket_handlers.go (0.0%)</option>
				
				<option value="file10">github.com/tktomaru/taskai/taskai-server/internal/auth/jwt.go (80.0%)</option>
				
				<option value="file11">github.com/tktomaru/taskai/taskai-server/internal/auth/password.go (75.0%)</option>
				
				<option value="file12">github.com/tktomaru/taskai/taskai-server/internal/config/config.go (0.0%)</option>
				
				<option value="file13">github.com/tktomaru/taskai/taskai-server/internal/database/database.go (0.0%)</option>
				
				<option value="file14">github.com/tktomaru/taskai/taskai-server/internal/models/models.go (0.0%)</option>
				
				<option value="file15">github.com/tktomaru/taskai/taskai-server/internal/parser/markdown.go (43.8%)</option>
				
				<option value="file16">github.com/tktomaru/taskai/taskai-server/internal/query/parser.go (67.8%)</option>
				
				<option value="file17">github.com/tktomaru/taskai/taskai-server/internal/query/sql_builder.go (47.4%)</option>
				
				<option value="file18">github.com/tktomaru/taskai/taskai-server/internal/repository/project_repository.go (0.0%)</option>
				
				<option value="file19">github.com/tktomaru/taskai/taskai-server/internal/repository/revision_repository.go (0.0%)</option>
				
				<option value="file20">github.com/tktomaru/taskai/taskai-server/internal/repository/task_repository.go (0.0%)</option>
				
				<option value="file21">github.com/tktomaru/taskai/taskai-server/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file22">github.com/tktomaru/taskai/taskai-server/internal/repository/view_repository.go (0.0%)</option>
				
				<option value="file23">github.com/tktomaru/taskai/taskai-server/internal/search/meilisearch.go (0.0%)</option>
				
				<option value="file24">github.com/tktomaru/taskai/taskai-server/internal/service/auth_service.go (0.0%)</option>
				
				<option value="file25">github.com/tktomaru/taskai/taskai-server/internal/service/project_service.go (0.0%)</option>
				
				<option value="file26">github.com/tktomaru/taskai/taskai-server/internal/service/revision_service.go (48.1%)</option>
				
				<option value="file27">github.com/tktomaru/taskai/taskai-server/internal/service/search_service.go (0.0%)</option>
				
				<option value="file28">github.com/tktomaru/taskai/taskai-server/internal/service/task_service.go (0.0%)</option>
				
				<option value="file29">github.com/tktomaru/taskai/taskai-server/internal/service/view_service.go (0.0%)</option>
				
				<option value="file30">github.com/tktomaru/taskai/taskai-server/internal/websocket/client.go (0.0%)</option>
				
				<option value="file31">github.com/tktomaru/taskai/taskai-server/internal/websocket/hub.go (81.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/tktomaru/taskai/taskai-server/internal/api"
        "github.com/tktomaru/taskai/taskai-server/internal/config"
        "github.com/tktomaru/taskai/taskai-server/internal/database"
        "github.com/tktomaru/taskai/taskai-server/internal/search"
        "github.com/tktomaru/taskai/taskai-server/internal/websocket"
)

const banner = `
████████╗ █████╗ ███████╗██╗  ██╗███╗   ███╗██████╗
╚══██╔══╝██╔══██╗██╔════╝██║ ██╔╝████╗ ████║██╔══██╗
   ██║   ███████║███████╗█████╔╝ ██╔████╔██║██║  ██║
   ██║   ██╔══██║╚════██║██╔═██╗ ██║╚██╔╝██║██║  ██║
   ██║   ██║  ██║███████║██║  ██╗██║ ╚═╝ ██║██████╔╝
   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═════╝

   TaskMD Server - Markdown-first Task Management
   Version: 0.1.0 (MVP)`

func main() <span class="cov0" title="0">{
        // Print banner
        fmt.Println(banner)

        // Load configuration
        log.Println("Loading configuration...")
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Configuration loaded successfully")
        log.Printf("Server: %s:%d", cfg.Server.Host, cfg.Server.Port)
        log.Printf("Database: %s@%s:%d/%s", cfg.Database.User, cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)

        // Connect to database
        log.Println("Connecting to database...")
        db, err := database.New(&amp;cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()
        log.Println("Database connection established")

        // Connect to Meilisearch (optional)
        var meili *search.MeilisearchClient
        meilisearchHost := os.Getenv("MEILISEARCH_HOST")
        if meilisearchHost != "" </span><span class="cov0" title="0">{
                log.Println("Connecting to Meilisearch...")
                meilisearchKey := os.Getenv("MEILISEARCH_KEY")
                var err error
                meili, err = search.NewMeilisearchClient(meilisearchHost, meilisearchKey, "tasks")
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WARNING: Failed to connect to Meilisearch: %v", err)
                        log.Println("Continuing without Meilisearch...")
                }</span> else<span class="cov0" title="0"> {
                        log.Println("Meilisearch connection established")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("Meilisearch not configured, using PostgreSQL full-text search")
        }</span>

        // Initialize WebSocket hub
        <span class="cov0" title="0">log.Println("Initializing WebSocket hub...")
        wsHub := websocket.NewHub()
        go wsHub.Run()
        log.Println("WebSocket hub started")

        // Create HTTP server
        log.Println("Initializing HTTP server...")
        apiServer := api.NewServer(cfg, db, meili, wsHub)

        addr := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
        server := &amp;http.Server{
                Addr:         addr,
                Handler:      apiServer.Router(),
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting HTTP server on %s", addr)
                log.Printf("Health check: http://%s/healthz", addr)
                log.Printf("API base URL: http://%s/api/v1", addr)

                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down server...")

        // Graceful shutdown
        ctx, cancel := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Server forced to shutdown: %v", err)
        }</span>

        // Wait for any remaining tasks
        <span class="cov0" title="0">time.Sleep(time.Second)

        log.Println("Server stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
)

// handleLogin handles POST /api/v1/auth/login
func (s *Server) handleLogin(c *gin.Context) <span class="cov0" title="0">{
        var req service.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">authService := service.NewAuthService(
                repository.NewUserRepository(s.db.DB),
                s.cfg.Auth.JWTSecret,
                s.cfg.Auth.JWTExpiresIn,
        )

        response, err := authService.Login(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error":   "authentication_failed",
                        "message": err.Error(),
                })
                return
        }</span>

        // Set cookie
        <span class="cov0" title="0">c.SetCookie(
                "token",
                response.Token,
                int(s.cfg.Auth.JWTExpiresIn.Seconds()),
                "/",
                "",
                false, // secure (set to true in production with HTTPS)
                true,  // httpOnly
        )

        c.JSON(http.StatusOK, gin.H{
                "data": response,
        })</span>
}

// handleLogout handles POST /api/v1/auth/logout
func (s *Server) handleLogout(c *gin.Context) <span class="cov0" title="0">{
        // Clear cookie
        c.SetCookie(
                "token",
                "",
                -1,
                "/",
                "",
                false,
                true,
        )

        c.JSON(http.StatusOK, gin.H{
                "message": "Logged out successfully",
        })
}</span>

// handleGetCurrentUser handles GET /api/v1/auth/me
func (s *Server) handleGetCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        // Get user from context (set by auth middleware)
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error":   "unauthorized",
                        "message": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">authService := service.NewAuthService(
                repository.NewUserRepository(s.db.DB),
                s.cfg.Auth.JWTSecret,
                s.cfg.Auth.JWTExpiresIn,
        )

        user, err := authService.GetUserByID(c.Request.Context(), userID.(string))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "user_not_found",
                        "message": "User not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": user,
        })</span>
}

// handleRegister handles POST /api/v1/auth/register
func (s *Server) handleRegister(c *gin.Context) <span class="cov0" title="0">{
        var req service.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">authService := service.NewAuthService(
                repository.NewUserRepository(s.db.DB),
                s.cfg.Auth.JWTSecret,
                s.cfg.Auth.JWTExpiresIn,
        )

        response, err := authService.Register(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "registration_failed",
                        "message": err.Error(),
                })
                return
        }</span>

        // Set cookie
        <span class="cov0" title="0">c.SetCookie(
                "token",
                response.Token,
                int(s.cfg.Auth.JWTExpiresIn.Seconds()),
                "/",
                "",
                false, // secure
                true,  // httpOnly
        )

        c.JSON(http.StatusCreated, gin.H{
                "data": response,
        })</span>
}

// AuthMiddleware validates JWT tokens
func (s *Server) AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Try to get token from cookie first
                token, err := c.Cookie("token")

                // If not in cookie, try Authorization header
                if err != nil || token == "" </span><span class="cov0" title="0">{
                        authHeader := c.GetHeader("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                        "error":   "unauthorized",
                                        "message": "Authentication required",
                                })
                                return
                        }</span>

                        // Extract Bearer token
                        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                        "error":   "unauthorized",
                                        "message": "Invalid authorization header format",
                                })
                                return
                        }</span>

                        <span class="cov0" title="0">token = parts[1]</span>
                }

                // Validate token
                <span class="cov0" title="0">authService := service.NewAuthService(
                        repository.NewUserRepository(s.db.DB),
                        s.cfg.Auth.JWTSecret,
                        s.cfg.Auth.JWTExpiresIn,
                )

                user, err := authService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error":   "unauthorized",
                                "message": "Invalid or expired token",
                        })
                        return
                }</span>

                // Set user in context
                <span class="cov0" title="0">c.Set("user_id", user.ID)
                c.Set("user_email", user.Email)
                c.Set("user", user)

                c.Next()</span>
        }
}

// OptionalAuthMiddleware validates JWT tokens but doesn't require them
func (s *Server) OptionalAuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Try to get token
                token, _ := c.Cookie("token")

                if token == "" </span><span class="cov0" title="0">{
                        authHeader := c.GetHeader("Authorization")
                        if authHeader != "" </span><span class="cov0" title="0">{
                                parts := strings.SplitN(authHeader, " ", 2)
                                if len(parts) == 2 &amp;&amp; parts[0] == "Bearer" </span><span class="cov0" title="0">{
                                        token = parts[1]
                                }</span>
                        }
                }

                // If token exists, validate it
                <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                        authService := service.NewAuthService(
                                repository.NewUserRepository(s.db.DB),
                                s.cfg.Auth.JWTSecret,
                                s.cfg.Auth.JWTExpiresIn,
                        )

                        user, err := authService.ValidateToken(token)
                        if err == nil </span><span class="cov0" title="0">{
                                c.Set("user_id", user.ID)
                                c.Set("user_email", user.Email)
                                c.Set("user", user)
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/config"
)

// LoggerMiddleware logs HTTP requests
func LoggerMiddleware(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                statusCode := c.Writer.Status()
                method := c.Request.Method
                clientIP := c.ClientIP()

                if query != "" </span><span class="cov0" title="0">{
                        path = path + "?" + query
                }</span>

                // Simple logging (replace with structured logger in production)
                <span class="cov0" title="0">if cfg.Logging.Format == "json" </span><span class="cov0" title="0">{
                        fmt.Printf(`{"time":"%s","status":%d,"latency":"%s","ip":"%s","method":"%s","path":"%s"}%s`,
                                time.Now().Format(time.RFC3339),
                                statusCode,
                                latency,
                                clientIP,
                                method,
                                path,
                                "\n",
                        )
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[%s] %d | %13v | %15s | %-7s %s\n",
                                time.Now().Format("2006/01/02 15:04:05"),
                                statusCode,
                                latency,
                                clientIP,
                                method,
                                path,
                        )
                }</span>
        }
}

// CORSMiddleware handles Cross-Origin Resource Sharing
func CORSMiddleware(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range cfg.Server.CORSOrigins </span><span class="cov0" title="0">{
                        if allowedOrigin == "*" || allowedOrigin == origin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        if origin != "" </span><span class="cov0" title="0">{
                                c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
                        }</span> else<span class="cov0" title="0"> if len(cfg.Server.CORSOrigins) &gt; 0 </span><span class="cov0" title="0">{
                                c.Writer.Header().Set("Access-Control-Allow-Origin", cfg.Server.CORSOrigins[0])
                        }</span>

                        <span class="cov0" title="0">c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")
                        c.Writer.Header().Set("Access-Control-Max-Age", "86400")</span>
                }

                <span class="cov0" title="0">if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// AuthMiddleware validates JWT tokens (placeholder)
func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // TODO: Implement JWT validation
                // For now, just pass through
                c.Next()
        }</span>
}

// RateLimitMiddleware implements rate limiting (placeholder)
func RateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // TODO: Implement rate limiting using Redis or in-memory store
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
)

// handleListProjects handles GET /api/v1/projects
func (s *Server) handleListProjects(c *gin.Context) <span class="cov0" title="0">{
        projectService := service.NewProjectService(repository.NewProjectRepository(s.db.DB))
        projects, err := projectService.List(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_server_error",
                        "message": "Failed to list projects",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": projects,
        })</span>
}

// handleCreateProject handles POST /api/v1/projects
func (s *Server) handleCreateProject(c *gin.Context) <span class="cov0" title="0">{
        var req service.CreateProjectRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">projectService := service.NewProjectService(repository.NewProjectRepository(s.db.DB))
        project, err := projectService.Create(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to create project",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "data": project,
        })</span>
}

// handleGetProject handles GET /api/v1/projects/:projectId
func (s *Server) handleGetProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        projectService := service.NewProjectService(repository.NewProjectRepository(s.db.DB))
        project, err := projectService.GetByID(c.Request.Context(), projectID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Project not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": project,
        })</span>
}

// handleUpdateProject handles PUT /api/v1/projects/:projectId
func (s *Server) handleUpdateProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        var req service.UpdateProjectRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">projectService := service.NewProjectService(repository.NewProjectRepository(s.db.DB))
        project, err := projectService.Update(c.Request.Context(), projectID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to update project",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": project,
        })</span>
}

// handleDeleteProject handles DELETE /api/v1/projects/:projectId
func (s *Server) handleDeleteProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        projectService := service.NewProjectService(repository.NewProjectRepository(s.db.DB))
        err := projectService.Delete(c.Request.Context(), projectID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Project not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
)

// handleGetTaskRevisions handles GET /api/v1/projects/:projectId/tasks/:taskId/revisions
func (s *Server) handleGetTaskRevisions(c *gin.Context) <span class="cov0" title="0">{
        taskID := c.Param("taskId")

        // Parse limit parameter
        limitStr := c.DefaultQuery("limit", "50")
        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">revisionService := service.NewRevisionService(
                repository.NewRevisionRepository(s.db.DB),
                repository.NewTaskRepository(s.db.DB),
        )

        revisions, err := revisionService.GetTaskRevisions(c.Request.Context(), taskID, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_server_error",
                        "message": "Failed to get revisions",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": revisions,
        })</span>
}

// handleGetRevision handles GET /api/v1/revisions/:revId
func (s *Server) handleGetRevision(c *gin.Context) <span class="cov0" title="0">{
        revIDStr := c.Param("revId")
        revID, err := strconv.ParseInt(revIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid revision ID",
                })
                return
        }</span>

        <span class="cov0" title="0">revisionService := service.NewRevisionService(
                repository.NewRevisionRepository(s.db.DB),
                repository.NewTaskRepository(s.db.DB),
        )

        revision, err := revisionService.GetRevision(c.Request.Context(), revID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Revision not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": revision,
        })</span>
}

// handleCompareRevisions handles GET /api/v1/revisions/compare?old=:oldRevId&amp;new=:newRevId
func (s *Server) handleCompareRevisions(c *gin.Context) <span class="cov0" title="0">{
        oldRevIDStr := c.Query("old")
        newRevIDStr := c.Query("new")

        oldRevID, err := strconv.ParseInt(oldRevIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid old revision ID",
                })
                return
        }</span>

        <span class="cov0" title="0">newRevID, err := strconv.ParseInt(newRevIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid new revision ID",
                })
                return
        }</span>

        <span class="cov0" title="0">revisionService := service.NewRevisionService(
                repository.NewRevisionRepository(s.db.DB),
                repository.NewTaskRepository(s.db.DB),
        )

        diff, err := revisionService.CompareRevisions(c.Request.Context(), oldRevID, newRevID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "comparison_failed",
                        "message": "Failed to compare revisions",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": diff,
        })</span>
}

// handleCompareWithCurrent handles GET /api/v1/projects/:projectId/tasks/:taskId/revisions/:revId/compare
func (s *Server) handleCompareWithCurrent(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        taskID := c.Param("taskId")
        revIDStr := c.Param("revId")

        revID, err := strconv.ParseInt(revIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid revision ID",
                })
                return
        }</span>

        <span class="cov0" title="0">revisionService := service.NewRevisionService(
                repository.NewRevisionRepository(s.db.DB),
                repository.NewTaskRepository(s.db.DB),
        )

        diff, err := revisionService.CompareWithCurrent(c.Request.Context(), projectID, taskID, revID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "comparison_failed",
                        "message": "Failed to compare with current version",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": diff,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/config"
        "github.com/tktomaru/taskai/taskai-server/internal/database"
        "github.com/tktomaru/taskai/taskai-server/internal/search"
        "github.com/tktomaru/taskai/taskai-server/internal/websocket"
)

// Server represents the HTTP server
type Server struct {
        cfg    *config.Config
        db     *database.DB
        meili  *search.MeilisearchClient
        wsHub  *websocket.Hub
        router *gin.Engine
}

// NewServer creates a new HTTP server
func NewServer(cfg *config.Config, db *database.DB, meili *search.MeilisearchClient, wsHub *websocket.Hub) *Server <span class="cov0" title="0">{
        // Set Gin mode based on log level
        if cfg.Logging.Level == "debug" </span><span class="cov0" title="0">{
                gin.SetMode(gin.DebugMode)
        }</span> else<span class="cov0" title="0"> {
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov0" title="0">router := gin.New()

        // Middleware
        router.Use(gin.Recovery())
        router.Use(LoggerMiddleware(cfg))
        router.Use(CORSMiddleware(cfg))

        s := &amp;Server{
                cfg:    cfg,
                db:     db,
                meili:  meili,
                wsHub:  wsHub,
                router: router,
        }

        s.setupRoutes()

        return s</span>
}

// setupRoutes configures all API routes
func (s *Server) setupRoutes() <span class="cov0" title="0">{
        // Health check
        s.router.GET("/healthz", s.handleHealthCheck)
        s.router.GET("/readyz", s.handleReadyCheck)

        // API v1 routes
        v1 := s.router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Public auth endpoints
                auth := v1.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/register", s.handleRegister)
                        auth.POST("/login", s.handleLogin)
                        auth.POST("/logout", s.handleLogout)
                        auth.GET("/me", s.AuthMiddleware(), s.handleGetCurrentUser)
                }</span>

                // Protected routes (require authentication)
                <span class="cov0" title="0">protected := v1.Group("")
                protected.Use(s.OptionalAuthMiddleware()) // Optional for now, can be changed to AuthMiddleware() for strict auth
                </span><span class="cov0" title="0">{
                        // Projects
                        projects := protected.Group("/projects")
                        </span><span class="cov0" title="0">{
                                projects.GET("", s.handleListProjects)
                                projects.POST("", s.handleCreateProject)
                                projects.GET("/:projectId", s.handleGetProject)
                                projects.PUT("/:projectId", s.handleUpdateProject)
                                projects.DELETE("/:projectId", s.handleDeleteProject)

                                // Tasks
                                tasks := projects.Group("/:projectId/tasks")
                                </span><span class="cov0" title="0">{
                                        tasks.GET("", s.handleListTasks)
                                        tasks.POST("", s.handleCreateTask)
                                        tasks.GET("/:taskId", s.handleGetTask)
                                        tasks.PUT("/:taskId", s.handleUpdateTask)
                                        tasks.DELETE("/:taskId", s.handleDeleteTask)

                                        // Task Revisions
                                        tasks.GET("/:taskId/revisions", s.handleGetTaskRevisions)
                                        tasks.GET("/:taskId/revisions/:revId/compare", s.handleCompareWithCurrent)
                                }</span>

                                // Saved Views
                                <span class="cov0" title="0">views := projects.Group("/:projectId/views")
                                </span><span class="cov0" title="0">{
                                        views.GET("", s.handleListViews)
                                        views.POST("", s.handleCreateView)
                                        views.GET("/:viewId", s.handleGetView)
                                        views.PUT("/:viewId", s.handleUpdateView)
                                        views.DELETE("/:viewId", s.handleDeleteView)
                                        views.POST("/:viewId/execute", s.handleExecuteView)
                                }</span>
                        }

                        // Task Packs (AI handoff)
                        <span class="cov0" title="0">protected.POST("/task-packs", s.handleGenerateTaskPack)

                        // Search
                        protected.POST("/search", s.handleSearch)

                        // Reindex
                        protected.POST("/projects/:projectId/reindex", s.handleReindexProject)

                        // Revisions (standalone)
                        revisions := protected.Group("/revisions")
                        </span><span class="cov0" title="0">{
                                revisions.GET("/:revId", s.handleGetRevision)
                                revisions.GET("/compare", s.handleCompareRevisions)
                        }</span>

                        // WebSocket
                        <span class="cov0" title="0">protected.GET("/ws/stats", s.handleWebSocketStats)</span>
                }

                // WebSocket endpoint (per project)
                <span class="cov0" title="0">v1.GET("/projects/:projectId/ws", s.OptionalAuthMiddleware(), s.handleWebSocket)</span>
        }
}

// Router returns the gin.Engine
func (s *Server) Router() *gin.Engine <span class="cov0" title="0">{
        return s.router
}</span>

// Health check handlers

func (s *Server) handleHealthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status": "ok",
                "time":   time.Now().UTC(),
        })
}</span>

func (s *Server) handleReadyCheck(c *gin.Context) <span class="cov0" title="0">{
        // Check database connectivity
        if err := s.db.HealthCheck(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "status": "unavailable",
                        "error":  "database not ready",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "status": "ready",
                "time":   time.Now().UTC(),
        })</span>
}

func (s *Server) handleGenerateTaskPack(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"message": "Generate task pack - not implemented"})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
)

// handleSearch handles POST /api/v1/search
func (s *Server) handleSearch(c *gin.Context) <span class="cov0" title="0">{
        var req service.SearchRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        // Use search service if Meilisearch is configured
        <span class="cov0" title="0">var searchService *service.SearchService
        if s.meili != nil </span><span class="cov0" title="0">{
                searchService = service.NewSearchService(
                        repository.NewTaskRepository(s.db.DB),
                        s.meili,
                )
        }</span> else<span class="cov0" title="0"> {
                searchService = service.NewSearchService(
                        repository.NewTaskRepository(s.db.DB),
                        nil,
                )
        }</span>

        <span class="cov0" title="0">results, err := searchService.Search(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "search_failed",
                        "message": "Failed to perform search",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": results,
        })</span>
}

// handleReindexProject handles POST /api/v1/projects/:projectId/reindex
func (s *Server) handleReindexProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        if s.meili == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{
                        "error":   "meilisearch_not_configured",
                        "message": "Meilisearch is not configured",
                })
                return
        }</span>

        <span class="cov0" title="0">searchService := service.NewSearchService(
                repository.NewTaskRepository(s.db.DB),
                s.meili,
        )

        err := searchService.ReindexAll(c.Request.Context(), projectID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "reindex_failed",
                        "message": "Failed to reindex project",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Project reindexed successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
        "github.com/tktomaru/taskai/taskai-server/internal/websocket"
)

// handleListTasks handles GET /api/v1/projects/:projectId/tasks
func (s *Server) handleListTasks(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        // Parse query parameters
        filters := &amp;repository.TaskFilters{}

        if statuses, ok := c.GetQueryArray("status"); ok </span><span class="cov0" title="0">{
                filters.Statuses = statuses
        }</span>

        <span class="cov0" title="0">if priorities, ok := c.GetQueryArray("priority"); ok </span><span class="cov0" title="0">{
                filters.Priorities = priorities
        }</span>

        <span class="cov0" title="0">if assignees, ok := c.GetQueryArray("assignee"); ok </span><span class="cov0" title="0">{
                filters.Assignees = assignees
        }</span>

        <span class="cov0" title="0">if labels, ok := c.GetQueryArray("label"); ok </span><span class="cov0" title="0">{
                filters.Labels = labels
        }</span>

        // Get tasks
        <span class="cov0" title="0">taskService := service.NewTaskService(repository.NewTaskRepository(s.db.DB))
        tasks, err := taskService.List(c.Request.Context(), projectID, filters)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_server_error",
                        "message": "Failed to list tasks",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": tasks,
        })</span>
}

// handleCreateTask handles POST /api/v1/projects/:projectId/tasks
func (s *Server) handleCreateTask(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        var req service.CreateTaskRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        // TODO: Get user ID from authentication context
        <span class="cov0" title="0">req.CreatedBy = "system"

        // Create task
        taskService := service.NewTaskService(repository.NewTaskRepository(s.db.DB))
        task, err := taskService.Create(c.Request.Context(), projectID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to create task",
                        "details": err.Error(),
                })
                return
        }</span>

        // Index in search engine (async)
        <span class="cov0" title="0">if s.meili != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        searchService := service.NewSearchService(repository.NewTaskRepository(s.db.DB), s.meili)
                        _ = searchService.IndexTask(c.Request.Context(), task)
                }</span>()
        }

        // Broadcast WebSocket event
        <span class="cov0" title="0">s.wsHub.Broadcast(websocket.EventTaskCreated, projectID, task.ID, task)

        c.JSON(http.StatusCreated, gin.H{
                "data": task,
        })</span>
}

// handleGetTask handles GET /api/v1/projects/:projectId/tasks/:taskId
func (s *Server) handleGetTask(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        taskID := c.Param("taskId")

        taskService := service.NewTaskService(repository.NewTaskRepository(s.db.DB))
        task, err := taskService.GetByID(c.Request.Context(), projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Task not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": task,
        })</span>
}

// handleUpdateTask handles PUT /api/v1/projects/:projectId/tasks/:taskId
func (s *Server) handleUpdateTask(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        taskID := c.Param("taskId")

        var req service.UpdateTaskRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        // TODO: Get user ID from authentication context
        <span class="cov0" title="0">req.UpdatedBy = "system"

        // Update task
        taskService := service.NewTaskService(repository.NewTaskRepository(s.db.DB))
        task, err := taskService.Update(c.Request.Context(), projectID, taskID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to update task",
                        "details": err.Error(),
                })
                return
        }</span>

        // Update search index (async)
        <span class="cov0" title="0">if s.meili != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        searchService := service.NewSearchService(repository.NewTaskRepository(s.db.DB), s.meili)
                        _ = searchService.UpdateTaskIndex(c.Request.Context(), task)
                }</span>()
        }

        // Broadcast WebSocket event
        <span class="cov0" title="0">s.wsHub.Broadcast(websocket.EventTaskUpdated, projectID, task.ID, task)

        c.JSON(http.StatusOK, gin.H{
                "data": task,
        })</span>
}

// handleDeleteTask handles DELETE /api/v1/projects/:projectId/tasks/:taskId
func (s *Server) handleDeleteTask(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        taskID := c.Param("taskId")

        taskService := service.NewTaskService(repository.NewTaskRepository(s.db.DB))
        err := taskService.Delete(c.Request.Context(), projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "Task not found",
                })
                return
        }</span>

        // Remove from search index (async)
        <span class="cov0" title="0">if s.meili != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        searchService := service.NewSearchService(repository.NewTaskRepository(s.db.DB), s.meili)
                        _ = searchService.DeleteTaskIndex(c.Request.Context(), taskID)
                }</span>()
        }

        // Broadcast WebSocket event
        <span class="cov0" title="0">s.wsHub.Broadcast(websocket.EventTaskDeleted, projectID, taskID, gin.H{"id": taskID})

        c.JSON(http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/service"
)

// handleListViews handles GET /api/v1/projects/:projectId/views
func (s *Server) handleListViews(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        // TODO: Get user ID from authentication context
        userID := "system"

        viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        views, err := viewService.List(c.Request.Context(), projectID, &amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "internal_server_error",
                        "message": "Failed to list views",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": views,
        })</span>
}

// handleCreateView handles POST /api/v1/projects/:projectId/views
func (s *Server) handleCreateView(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")

        var req service.CreateViewRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        // TODO: Get user ID from authentication context
        <span class="cov0" title="0">req.OwnerUserID = "system"

        viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        view, err := viewService.Create(c.Request.Context(), projectID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to create view",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "data": view,
        })</span>
}

// handleGetView handles GET /api/v1/projects/:projectId/views/:viewId
func (s *Server) handleGetView(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        viewID := c.Param("viewId")

        viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        view, err := viewService.GetByID(c.Request.Context(), projectID, viewID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "View not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": view,
        })</span>
}

// handleUpdateView handles PUT /api/v1/projects/:projectId/views/:viewId
func (s *Server) handleUpdateView(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        viewID := c.Param("viewId")

        var req service.UpdateViewRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Invalid request body",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        view, err := viewService.Update(c.Request.Context(), projectID, viewID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "validation_error",
                        "message": "Failed to update view",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": view,
        })</span>
}

// handleDeleteView handles DELETE /api/v1/projects/:projectId/views/:viewId
func (s *Server) handleDeleteView(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        viewID := c.Param("viewId")

        viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        err := viewService.Delete(c.Request.Context(), projectID, viewID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "not_found",
                        "message": "View not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusNoContent, nil)</span>
}

// handleExecuteView handles POST /api/v1/projects/:projectId/views/:viewId/execute
func (s *Server) handleExecuteView(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        viewID := c.Param("viewId")

        viewService := service.NewViewService(repository.NewViewRepository(s.db.DB))
        tasks, err := viewService.Execute(c.Request.Context(), projectID, viewID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "execution_error",
                        "message": "Failed to execute view",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": tasks,
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
        ws "github.com/tktomaru/taskai/taskai-server/internal/websocket"
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                // Allow all origins for now
                // In production, this should check against allowed origins
                return true
        }</span>,
}

// handleWebSocket handles WebSocket connections for real-time updates
// GET /api/v1/projects/:projectId/ws
func (s *Server) handleWebSocket(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "invalid_request",
                        "message": "Project ID is required",
                })
                return
        }</span>

        // Get user ID from context (set by auth middleware)
        <span class="cov0" title="0">userID := ""
        if userIDVal, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                userID = userIDVal.(string)
        }</span>

        // Upgrade HTTP connection to WebSocket
        <span class="cov0" title="0">conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to upgrade WebSocket: %v", err)
                return
        }</span>

        // Create and register client
        <span class="cov0" title="0">client := ws.NewClient(s.wsHub, conn, projectID, userID)
        s.wsHub.Register &lt;- client

        // Start client goroutines
        client.Start()

        log.Printf("WebSocket connection established for project %s (user: %s)", projectID, userID)</span>
}

// handleWebSocketStats returns WebSocket connection statistics
// GET /api/v1/ws/stats
func (s *Server) handleWebSocketStats(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Query("project_id")

        stats := gin.H{
                "status": "ok",
        }

        if projectID != "" </span><span class="cov0" title="0">{
                stats["project_id"] = projectID
                stats["client_count"] = s.wsHub.GetClientCount(projectID)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// Claims represents JWT claims
type Claims struct {
        UserID string `json:"user_id"`
        Email  string `json:"email"`
        jwt.RegisteredClaims
}

// JWTManager manages JWT tokens
type JWTManager struct {
        secret     string
        expiresIn  time.Duration
}

// NewJWTManager creates a new JWT manager
func NewJWTManager(secret string, expiresIn time.Duration) *JWTManager <span class="cov9" title="5">{
        return &amp;JWTManager{
                secret:    secret,
                expiresIn: expiresIn,
        }
}</span>

// GenerateToken generates a JWT token for a user
func (m *JWTManager) GenerateToken(user *models.User) (string, error) <span class="cov6" title="3">{
        now := time.Now()
        claims := &amp;Claims{
                UserID: user.ID,
                Email:  user.Email,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(now.Add(m.expiresIn)),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(m.secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov6" title="3">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns claims
func (m *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov10" title="6">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov6" title="3">{
                // Verify signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov6" title="3">return []byte(m.secret), nil</span>
        })

        <span class="cov10" title="6">if err != nil </span><span class="cov9" title="5">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov1" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov1" title="1">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid claims type")
        }</span>

        <span class="cov1" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "fmt"
        "strings"

        "golang.org/x/crypto/argon2"
)

const (
        // Argon2 parameters
        argonTime    = 1
        argonMemory  = 64 * 1024
        argonThreads = 4
        argonKeyLen  = 32
        saltLen      = 16
)

// PasswordHasher handles password hashing and verification
type PasswordHasher struct{}

// NewPasswordHasher creates a new password hasher
func NewPasswordHasher() *PasswordHasher <span class="cov6" title="3">{
        return &amp;PasswordHasher{}
}</span>

// HashPassword hashes a password using Argon2
func (h *PasswordHasher) HashPassword(password string) (string, error) <span class="cov10" title="7">{
        // Generate random salt
        salt := make([]byte, saltLen)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        // Hash password
        <span class="cov10" title="7">hash := argon2.IDKey([]byte(password), salt, argonTime, argonMemory, argonThreads, argonKeyLen)

        // Encode as: $argon2id$v=19$m=65536,t=1,p=4$&lt;salt&gt;$&lt;hash&gt;
        encoded := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
                argon2.Version,
                argonMemory,
                argonTime,
                argonThreads,
                base64.RawStdEncoding.EncodeToString(salt),
                base64.RawStdEncoding.EncodeToString(hash),
        )

        return encoded, nil</span>
}

// VerifyPassword verifies a password against a hash
func (h *PasswordHasher) VerifyPassword(password, encodedHash string) (bool, error) <span class="cov9" title="6">{
        // Parse encoded hash
        parts := strings.Split(encodedHash, "$")
        if len(parts) != 6 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid hash format")
        }</span>

        <span class="cov9" title="6">if parts[1] != "argon2id" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("unsupported algorithm")
        }</span>

        // Parse parameters
        <span class="cov9" title="6">var version int
        if _, err := fmt.Sscanf(parts[2], "v=%d", &amp;version); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid version: %w", err)
        }</span>

        <span class="cov9" title="6">var memory, time, threads uint32
        if _, err := fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &amp;memory, &amp;time, &amp;threads); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid parameters: %w", err)
        }</span>

        // Decode salt
        <span class="cov9" title="6">salt, err := base64.RawStdEncoding.DecodeString(parts[4])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid salt: %w", err)
        }</span>

        // Decode hash
        <span class="cov9" title="6">hash, err := base64.RawStdEncoding.DecodeString(parts[5])
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid hash: %w", err)
        }</span>

        // Hash the provided password with the same parameters
        <span class="cov9" title="6">providedHash := argon2.IDKey([]byte(password), salt, time, memory, uint8(threads), uint32(len(hash)))

        // Compare hashes using constant-time comparison
        if subtle.ConstantTimeCompare(hash, providedHash) == 1 </span><span class="cov6" title="3">{
                return true, nil
        }</span>

        <span class="cov6" title="3">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

// Config holds all configuration for the application
type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        Auth     AuthConfig
        Logging  LoggingConfig
}

// ServerConfig holds server configuration
type ServerConfig struct {
        Port            int
        Host            string
        ReadTimeout     time.Duration
        WriteTimeout    time.Duration
        ShutdownTimeout time.Duration
        CORSOrigins     []string
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host     string
        Port     int
        User     string
        Password string
        DBName   string
        SSLMode  string
        MaxConns int
        MinConns int
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        Mode         string // "oidc" or "password"
        JWTSecret    string
        JWTExpiresIn time.Duration

        // OIDC settings
        OIDCIssuer       string
        OIDCClientID     string
        OIDCClientSecret string
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level  string
        Format string // "json" or "text"
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists (ignore error if file doesn't exist)
        _ = godotenv.Load()

        cfg := &amp;Config{
                Server: ServerConfig{
                        Port:            getEnvAsInt("PORT", 8080),
                        Host:            getEnv("HOST", "0.0.0.0"),
                        ReadTimeout:     getEnvAsDuration("READ_TIMEOUT", 15*time.Second),
                        WriteTimeout:    getEnvAsDuration("WRITE_TIMEOUT", 15*time.Second),
                        ShutdownTimeout: getEnvAsDuration("SHUTDOWN_TIMEOUT", 10*time.Second),
                        CORSOrigins:     getEnvAsSlice("CORS_ORIGINS", []string{"http://localhost:5173"}),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnvAsInt("DB_PORT", 5432),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", ""),
                        DBName:   getEnv("DB_NAME", "taskmd"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                        MaxConns: getEnvAsInt("DB_MAX_CONNS", 25),
                        MinConns: getEnvAsInt("DB_MIN_CONNS", 5),
                },
                Auth: AuthConfig{
                        Mode:         getEnv("AUTH_MODE", "password"),
                        JWTSecret:    getEnv("JWT_SECRET", "change-me-in-production"),
                        JWTExpiresIn: getEnvAsDuration("JWT_EXPIRES_IN", 24*time.Hour),

                        OIDCIssuer:       getEnv("OIDC_ISSUER", ""),
                        OIDCClientID:     getEnv("OIDC_CLIENT_ID", ""),
                        OIDCClientSecret: getEnv("OIDC_CLIENT_SECRET", ""),
                },
                Logging: LoggingConfig{
                        Level:  getEnv("LOG_LEVEL", "info"),
                        Format: getEnv("LOG_FORMAT", "json"),
                },
        }

        // Validate configuration
        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Database.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DB_PASSWORD is required")
        }</span>

        <span class="cov0" title="0">if c.Auth.Mode == "oidc" </span><span class="cov0" title="0">{
                if c.Auth.OIDCIssuer == "" || c.Auth.OIDCClientID == "" || c.Auth.OIDCClientSecret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("OIDC configuration is incomplete")
                }</span>
        }

        <span class="cov0" title="0">if c.Auth.JWTSecret == "change-me-in-production" </span><span class="cov0" title="0">{
                fmt.Println("WARNING: Using default JWT secret. Please set JWT_SECRET in production!")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDSN returns the database connection string
func (c *DatabaseConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.DBName, c.SSLMode,
        )
}</span>

// Helper functions

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        valueStr := os.Getenv(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">value, err := strconv.Atoi(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return value</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        valueStr := os.Getenv(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">value, err := time.ParseDuration(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return value</span>
}

func getEnvAsSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        valueStr := os.Getenv(key)
        if valueStr == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        // Simple comma-separated parsing
        // For more complex parsing, use a proper CSV library
        <span class="cov0" title="0">var result []string
        for _, v := range splitByComma(valueStr) </span><span class="cov0" title="0">{
                if trimmed := trim(v); trimmed != "" </span><span class="cov0" title="0">{
                        result = append(result, trimmed)
                }</span>
        }

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return result</span>
}

// Simple helper functions to avoid external dependencies
func splitByComma(s string) []string <span class="cov0" title="0">{
        var result []string
        var current string

        for _, char := range s </span><span class="cov0" title="0">{
                if char == ',' </span><span class="cov0" title="0">{
                        result = append(result, current)
                        current = ""
                }</span> else<span class="cov0" title="0"> {
                        current += string(char)
                }</span>
        }

        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                result = append(result, current)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func trim(s string) string <span class="cov0" title="0">{
        start := 0
        end := len(s)

        for start &lt; end &amp;&amp; (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') </span><span class="cov0" title="0">{
                start++
        }</span>

        <span class="cov0" title="0">for end &gt; start &amp;&amp; (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') </span><span class="cov0" title="0">{
                end--
        }</span>

        <span class="cov0" title="0">return s[start:end]</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        "github.com/tktomaru/taskai/taskai-server/internal/config"
)

// DB wraps the database connection
type DB struct {
        *sqlx.DB
}

// New creates a new database connection
func New(cfg *config.DatabaseConfig) (*DB, error) <span class="cov0" title="0">{
        dsn := cfg.GetDSN()

        db, err := sqlx.Connect("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.MaxConns)
        db.SetMaxIdleConns(cfg.MinConns)
        db.SetConnMaxLifetime(time.Hour)

        // Verify connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DB{DB: db}, nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        return db.DB.Close()
}</span>

// HealthCheck checks if the database is healthy
func (db *DB) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()

        var result int
        if err := db.GetContext(ctx, &amp;result, "SELECT 1"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Transaction executes a function within a database transaction
func (db *DB) Transaction(ctx context.Context, fn func(*sqlx.Tx) error) error <span class="cov0" title="0">{
        tx, err := db.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                        panic(p)</span>
                }
        }()

        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("transaction error: %v, rollback error: %w", err, rbErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"
)

// Task represents a task in the system
type Task struct {
        ID           string         `json:"id" db:"id"`
        ProjectID    string         `json:"project_id" db:"project_id"`
        Title        string         `json:"title" db:"title"`
        Status       TaskStatus     `json:"status" db:"status"`
        Priority     TaskPriority   `json:"priority" db:"priority"`
        Assignees    StringArray    `json:"assignees" db:"assignees"`
        Labels       StringArray    `json:"labels" db:"labels"`
        StartDate    *time.Time     `json:"start_date,omitempty" db:"start_date"`
        DueDate      *time.Time     `json:"due_date,omitempty" db:"due_date"`
        MarkdownBody string         `json:"markdown_body" db:"markdown_body"`
        ExtraMeta    JSONB          `json:"extra_meta" db:"extra_meta"`
        CreatedAt    time.Time      `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time      `json:"updated_at" db:"updated_at"`
        CompletedAt  *time.Time     `json:"completed_at,omitempty" db:"completed_at"`
        ArchivedAt   *time.Time     `json:"archived_at,omitempty" db:"archived_at"`
        CreatedBy    *string        `json:"created_by,omitempty" db:"created_by"`
        UpdatedBy    *string        `json:"updated_by,omitempty" db:"updated_by"`
}

// SavedView represents a saved query view
type SavedView struct {
        ID               string    `json:"id" db:"id"`
        ProjectID        string    `json:"project_id" db:"project_id"`
        OwnerUserID      *string   `json:"owner_user_id,omitempty" db:"owner_user_id"`
        Name             string    `json:"name" db:"name"`
        Description      *string   `json:"description,omitempty" db:"description"`
        Scope            ViewScope `json:"scope" db:"scope"`
        RawQuery         string    `json:"raw_query" db:"raw_query"`
        NormalizedQuery  string    `json:"normalized_query" db:"normalized_query"`
        Presentation     JSONB     `json:"presentation" db:"presentation"`
        UseCount         int       `json:"use_count" db:"use_count"`
        LastUsedAt       *time.Time `json:"last_used_at,omitempty" db:"last_used_at"`
        CreatedAt        time.Time `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time `json:"updated_at" db:"updated_at"`
}

// Project represents a project
type Project struct {
        ID          string            `json:"id" db:"id"`
        Name        string            `json:"name" db:"name"`
        Description *string           `json:"description,omitempty" db:"description"`
        Visibility  ProjectVisibility `json:"visibility" db:"visibility"`
        Settings    JSONB             `json:"settings" db:"settings"`
        CreatedAt   time.Time         `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at" db:"updated_at"`
        ArchivedAt  *time.Time        `json:"archived_at,omitempty" db:"archived_at"`
}

// User represents a user
type User struct {
        ID           string     `json:"id" db:"id"`
        Email        string     `json:"email" db:"email"`
        Name         string     `json:"name" db:"name"`
        AvatarURL    *string    `json:"avatar_url,omitempty" db:"avatar_url"`
        PasswordHash *string    `json:"-" db:"password_hash"`
        OIDCProvider *string    `json:"oidc_provider,omitempty" db:"oidc_provider"`
        OIDCSubject  *string    `json:"oidc_subject,omitempty" db:"oidc_subject"`
        Preferences  JSONB      `json:"preferences" db:"preferences"`
        CreatedAt    time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time  `json:"updated_at" db:"updated_at"`
        LastLoginAt  *time.Time `json:"last_login_at,omitempty" db:"last_login_at"`
}

// TaskRelation represents a relation between tasks
type TaskRelation struct {
        SourceTaskID string       `json:"source_task_id" db:"source_task_id"`
        TargetTaskID string       `json:"target_task_id" db:"target_task_id"`
        RelationType RelationType `json:"relation_type" db:"relation_type"`
        CreatedAt    time.Time    `json:"created_at" db:"created_at"`
        CreatedBy    *string      `json:"created_by,omitempty" db:"created_by"`
}

// TaskRevision represents a task revision
type TaskRevision struct {
        RevID         int64     `json:"rev_id" db:"rev_id"`
        TaskID        string    `json:"task_id" db:"task_id"`
        EditorUserID  *string   `json:"editor_user_id,omitempty" db:"editor_user_id"`
        MarkdownBody  string    `json:"markdown_body" db:"markdown_body"`
        MetaSnapshot  JSONB     `json:"meta_snapshot" db:"meta_snapshot"`
        ChangeSummary *string   `json:"change_summary,omitempty" db:"change_summary"`
        CreatedAt     time.Time `json:"created_at" db:"created_at"`
}

// AuditLog represents an audit log entry
type AuditLog struct {
        ID          int64       `json:"id" db:"id"`
        ActorUserID *string     `json:"actor_user_id,omitempty" db:"actor_user_id"`
        ActorIP     *string     `json:"actor_ip,omitempty" db:"actor_ip"`
        Action      AuditAction `json:"action" db:"action"`
        TargetType  string      `json:"target_type" db:"target_type"`
        TargetID    string      `json:"target_id" db:"target_id"`
        Detail      JSONB       `json:"detail" db:"detail"`
        CreatedAt   time.Time   `json:"created_at" db:"created_at"`
}

// Enums

type TaskStatus string

const (
        TaskStatusOpen       TaskStatus = "open"
        TaskStatusInProgress TaskStatus = "in_progress"
        TaskStatusReview     TaskStatus = "review"
        TaskStatusBlocked    TaskStatus = "blocked"
        TaskStatusDone       TaskStatus = "done"
        TaskStatusArchived   TaskStatus = "archived"
)

type TaskPriority string

const (
        TaskPriorityP0 TaskPriority = "P0"
        TaskPriorityP1 TaskPriority = "P1"
        TaskPriorityP2 TaskPriority = "P2"
        TaskPriorityP3 TaskPriority = "P3"
        TaskPriorityP4 TaskPriority = "P4"
)

type ProjectVisibility string

const (
        ProjectVisibilityPrivate ProjectVisibility = "private"
        ProjectVisibilityTeam    ProjectVisibility = "team"
        ProjectVisibilityPublic  ProjectVisibility = "public"
)

type ViewScope string

const (
        ViewScopePrivate ViewScope = "private"
        ViewScopeShared  ViewScope = "shared"
)

type RelationType string

const (
        RelationTypeParent       RelationType = "parent"
        RelationTypeChild        RelationType = "child"
        RelationTypeBlocks       RelationType = "blocks"
        RelationTypeBlockedBy    RelationType = "blocked_by"
        RelationTypeRelated      RelationType = "related"
        RelationTypeDuplicates   RelationType = "duplicates"
        RelationTypeDuplicatedBy RelationType = "duplicated_by"
)

type AuditAction string

const (
        AuditActionTaskCreate               AuditAction = "task.create"
        AuditActionTaskUpdate               AuditAction = "task.update"
        AuditActionTaskDelete               AuditAction = "task.delete"
        AuditActionTaskStatusChange         AuditAction = "task.status_change"
        AuditActionTaskAssign               AuditAction = "task.assign"
        AuditActionViewCreate               AuditAction = "view.create"
        AuditActionViewUpdate               AuditAction = "view.update"
        AuditActionViewDelete               AuditAction = "view.delete"
        AuditActionViewShare                AuditAction = "view.share"
        AuditActionProjectCreate            AuditAction = "project.create"
        AuditActionProjectUpdate            AuditAction = "project.update"
        AuditActionProjectDelete            AuditAction = "project.delete"
        AuditActionProjectMemberAdd         AuditAction = "project.member_add"
        AuditActionProjectMemberRemove      AuditAction = "project.member_remove"
        AuditActionProjectMemberRoleChange  AuditAction = "project.member_role_change"
)

// Custom types for PostgreSQL compatibility

// StringArray is a custom type for PostgreSQL text arrays
type StringArray []string

// Value implements the driver.Valuer interface
func (a StringArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if len(a) == 0 </span><span class="cov0" title="0">{
                return "{}", nil
        }</span>

        // Build PostgreSQL array literal
        <span class="cov0" title="0">s := "{"
        for i, v := range a </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        s += ","
                }</span>
                // Escape quotes and backslashes
                <span class="cov0" title="0">escaped := ""
                for _, c := range v </span><span class="cov0" title="0">{
                        if c == '"' || c == '\\' </span><span class="cov0" title="0">{
                                escaped += "\\"
                        }</span>
                        <span class="cov0" title="0">escaped += string(c)</span>
                }
                <span class="cov0" title="0">s += `"` + escaped + `"`</span>
        }
        <span class="cov0" title="0">s += "}"

        return s, nil</span>
}

// Scan implements the sql.Scanner interface
func (a *StringArray) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *a = nil
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(v)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(v))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan type %T into StringArray", value)</span>
        }
}

func (a *StringArray) scanBytes(src []byte) error <span class="cov0" title="0">{
        // Simple PostgreSQL array parser
        // This is a basic implementation; for production, consider using a library
        if len(src) == 0 || string(src) == "{}" </span><span class="cov0" title="0">{
                *a = []string{}
                return nil
        }</span>

        // Remove outer braces
        <span class="cov0" title="0">if src[0] == '{' &amp;&amp; src[len(src)-1] == '}' </span><span class="cov0" title="0">{
                src = src[1 : len(src)-1]
        }</span>

        // Split by comma (simplified - doesn't handle nested arrays or escaped commas)
        <span class="cov0" title="0">var result []string
        current := ""
        inQuote := false

        for i := 0; i &lt; len(src); i++ </span><span class="cov0" title="0">{
                c := src[i]

                if c == '"' &amp;&amp; (i == 0 || src[i-1] != '\\') </span><span class="cov0" title="0">{
                        inQuote = !inQuote
                        continue</span>
                }

                <span class="cov0" title="0">if c == ',' &amp;&amp; !inQuote </span><span class="cov0" title="0">{
                        result = append(result, current)
                        current = ""
                        continue</span>
                }

                <span class="cov0" title="0">current += string(c)</span>
        }

        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                result = append(result, current)
        }</span>

        <span class="cov0" title="0">*a = result
        return nil</span>
}

// JSONB is a custom type for PostgreSQL JSONB
type JSONB map[string]interface{}

// Value implements the driver.Valuer interface
func (j JSONB) Value() (driver.Value, error) <span class="cov0" title="0">{
        if j == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(j)</span>
}

// Scan implements the sql.Scanner interface
func (j *JSONB) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *j = nil
                return nil
        }</span>

        <span class="cov0" title="0">var data []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov0" title="0">
                data = v</span>
        case string:<span class="cov0" title="0">
                data = []byte(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan type %T into JSONB", value)</span>
        }

        <span class="cov0" title="0">return json.Unmarshal(data, j)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package parser

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "gopkg.in/yaml.v3"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// TaskMetadata represents the YAML frontmatter metadata
type TaskMetadata struct {
        ID        string    `yaml:"id"`
        Status    string    `yaml:"status"`
        Priority  string    `yaml:"priority"`
        Assignees []string  `yaml:"assignees"`
        Labels    []string  `yaml:"labels"`
        StartDate *string   `yaml:"start"`
        DueDate   *string   `yaml:"due"`
        ExtraMeta yaml.Node `yaml:",inline"`
}

// ParsedTask represents a parsed task with metadata and body
type ParsedTask struct {
        Metadata     TaskMetadata
        MarkdownBody string
        Title        string
}

// MarkdownParser handles parsing of task markdown
type MarkdownParser struct{}

// NewMarkdownParser creates a new markdown parser
func NewMarkdownParser() *MarkdownParser <span class="cov1" title="1">{
        return &amp;MarkdownParser{}
}</span>

// Parse parses a markdown document with YAML frontmatter
func (p *MarkdownParser) Parse(markdown string) (*ParsedTask, error) <span class="cov10" title="5">{
        // Extract title, metadata, and body
        title, yamlContent, _, err := p.extractParts(markdown)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to extract parts: %w", err)
        }</span>

        // Parse YAML metadata
        <span class="cov7" title="3">var metadata TaskMetadata
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML metadata: %w", err)
        }</span>

        // Validate required fields
        <span class="cov7" title="3">if err := p.validateMetadata(&amp;metadata); err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;ParsedTask{
                Metadata:     metadata,
                MarkdownBody: markdown, // Store original markdown
                Title:        title,
        }, nil</span>
}

// extractParts extracts title, YAML frontmatter, and body from markdown
func (p *MarkdownParser) extractParts(markdown string) (title, yamlContent, body string, err error) <span class="cov10" title="5">{
        // Pattern: ## ID: Title
        titlePattern := regexp.MustCompile(`(?m)^##\s+([A-Z]+-\d+):\s+(.+)$`)
        titleMatch := titlePattern.FindStringSubmatch(markdown)

        if titleMatch == nil </span><span class="cov1" title="1">{
                return "", "", "", fmt.Errorf("task title not found (expected format: ## ID: Title)")
        }</span>

        <span class="cov8" title="4">title = strings.TrimSpace(titleMatch[2])

        // Extract YAML frontmatter from code block
        // Pattern: ```yaml ... ```
        yamlPattern := regexp.MustCompile("(?s)```yaml\n(.*?)\n```")
        yamlMatch := yamlPattern.FindStringSubmatch(markdown)

        if yamlMatch == nil </span><span class="cov1" title="1">{
                return "", "", "", fmt.Errorf("YAML frontmatter not found (expected ```yaml ... ```)")
        }</span>

        <span class="cov7" title="3">yamlContent = yamlMatch[1]

        // Body is everything after the YAML block
        yamlEndIdx := strings.Index(markdown, yamlMatch[0]) + len(yamlMatch[0])
        body = strings.TrimSpace(markdown[yamlEndIdx:])

        return title, yamlContent, body, nil</span>
}

// validateMetadata validates required fields
func (p *MarkdownParser) validateMetadata(meta *TaskMetadata) error <span class="cov7" title="3">{
        if meta.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("id is required")
        }</span>

        <span class="cov7" title="3">if meta.Status == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("status is required")
        }</span>

        <span class="cov7" title="3">if meta.Priority == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("priority is required")
        }</span>

        // Validate status enum
        <span class="cov7" title="3">validStatuses := map[string]bool{
                "open": true, "in_progress": true, "review": true,
                "blocked": true, "done": true, "archived": true,
        }
        if !validStatuses[meta.Status] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid status: %s (must be one of: open, in_progress, review, blocked, done, archived)", meta.Status)
        }</span>

        // Validate priority enum
        <span class="cov4" title="2">validPriorities := map[string]bool{
                "P0": true, "P1": true, "P2": true, "P3": true, "P4": true,
        }
        if !validPriorities[meta.Priority] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid priority: %s (must be one of: P0, P1, P2, P3, P4)", meta.Priority)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ToTask converts ParsedTask to models.Task
func (pt *ParsedTask) ToTask(projectID string) (*models.Task, error) <span class="cov0" title="0">{
        task := &amp;models.Task{
                ID:           pt.Metadata.ID,
                ProjectID:    projectID,
                Title:        pt.Title,
                Status:       models.TaskStatus(pt.Metadata.Status),
                Priority:     models.TaskPriority(pt.Metadata.Priority),
                Assignees:    models.StringArray(pt.Metadata.Assignees),
                Labels:       models.StringArray(pt.Metadata.Labels),
                MarkdownBody: pt.MarkdownBody,
                ExtraMeta:    make(models.JSONB),
        }

        // Parse dates
        if pt.Metadata.StartDate != nil </span><span class="cov0" title="0">{
                startDate, err := parseDate(*pt.Metadata.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid start date: %w", err)
                }</span>
                <span class="cov0" title="0">task.StartDate = &amp;startDate</span>
        }

        <span class="cov0" title="0">if pt.Metadata.DueDate != nil </span><span class="cov0" title="0">{
                dueDate, err := parseDate(*pt.Metadata.DueDate)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid due date: %w", err)
                }</span>
                <span class="cov0" title="0">task.DueDate = &amp;dueDate</span>
        }

        <span class="cov0" title="0">return task, nil</span>
}

// parseDate parses a date string in YYYY-MM-DD format
func parseDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        return time.Parse("2006-01-02", dateStr)
}</span>

// ExtractAcceptanceCriteria extracts acceptance criteria from markdown body
func ExtractAcceptanceCriteria(markdown string) []string <span class="cov1" title="1">{
        var criteria []string

        // Pattern: - [ ] ... or - [x] ...
        acPattern := regexp.MustCompile(`(?m)^-\s+\[([ x])\]\s+(.+)$`)
        matches := acPattern.FindAllStringSubmatch(markdown, -1)

        for _, match := range matches </span><span class="cov8" title="4">{
                if len(match) &gt;= 3 </span><span class="cov8" title="4">{
                        criteria = append(criteria, match[2])
                }</span>
        }

        <span class="cov1" title="1">return criteria</span>
}

// GenerateMarkdown generates markdown from task data (for editing)
func GenerateMarkdown(task *models.Task) string <span class="cov0" title="0">{
        var sb strings.Builder

        // Title
        sb.WriteString(fmt.Sprintf("## %s: %s\n\n", task.ID, task.Title))

        // YAML frontmatter
        sb.WriteString("```yaml\n")
        sb.WriteString(fmt.Sprintf("id: %s\n", task.ID))
        sb.WriteString(fmt.Sprintf("status: %s\n", task.Status))
        sb.WriteString(fmt.Sprintf("priority: %s\n", task.Priority))

        if len(task.Assignees) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("assignees: [")
                for i, assignee := range task.Assignees </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(assignee)</span>
                }
                <span class="cov0" title="0">sb.WriteString("]\n")</span>
        }

        <span class="cov0" title="0">if task.StartDate != nil </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("start: %s\n", task.StartDate.Format("2006-01-02")))
        }</span>

        <span class="cov0" title="0">if task.DueDate != nil </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("due: %s\n", task.DueDate.Format("2006-01-02")))
        }</span>

        <span class="cov0" title="0">if len(task.Labels) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("labels: [")
                for i, label := range task.Labels </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(label)</span>
                }
                <span class="cov0" title="0">sb.WriteString("]\n")</span>
        }

        <span class="cov0" title="0">sb.WriteString("```\n\n")

        // Body (extract from original markdown_body, skipping title and YAML)
        body := extractBody(task.MarkdownBody)
        sb.WriteString(body)

        return sb.String()</span>
}

// extractBody extracts the body part from markdown (after YAML block)
func extractBody(markdown string) string <span class="cov0" title="0">{
        // Find the end of YAML block
        yamlPattern := regexp.MustCompile("(?s)```yaml\n.*?\n```")
        match := yamlPattern.FindStringIndex(markdown)

        if match == nil </span><span class="cov0" title="0">{
                return markdown
        }</span>

        // Return everything after the YAML block
        <span class="cov0" title="0">return strings.TrimSpace(markdown[match[1]:])</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package query

import (
        "fmt"
        "regexp"
        "strings"
        "time"
)

// QueryParser parses SavedView query strings
type QueryParser struct{}

// NewQueryParser creates a new query parser
func NewQueryParser() *QueryParser <span class="cov2" title="2">{
        return &amp;QueryParser{}
}</span>

// ParsedQuery represents a parsed query
type ParsedQuery struct {
        Filters   []Filter
        Sort      *SortOption
        Group     *GroupOption
        Limit     int
        ViewType  string
        Columns   []string
}

// Filter represents a single filter condition
type Filter struct {
        Key      string
        Operator string // "=", "!=", "&gt;", "&lt;", "&gt;=", "&lt;=", "in", "not_in", "contains"
        Value    interface{}
        Negate   bool
}

// SortOption represents sorting configuration
type SortOption struct {
        Field string
        Order string // "asc" or "desc"
}

// GroupOption represents grouping configuration
type GroupOption struct {
        Field string
}

// Parse parses a query string
func (p *QueryParser) Parse(queryStr string) (*ParsedQuery, error) <span class="cov5" title="14">{
        result := &amp;ParsedQuery{
                Filters: []Filter{},
                Limit:   100,
        }

        // Split by spaces (but respect parentheses and quotes)
        tokens := p.tokenize(queryStr)

        for _, token := range tokens </span><span class="cov5" title="20">{
                token = strings.TrimSpace(token)
                if token == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for display options
                <span class="cov5" title="20">if strings.HasPrefix(token, "sort:") </span><span class="cov1" title="1">{
                        sortOpt, err := p.parseSort(token)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">result.Sort = sortOpt
                        continue</span>
                }

                <span class="cov5" title="19">if strings.HasPrefix(token, "group:") </span><span class="cov0" title="0">{
                        groupOpt, err := p.parseGroup(token)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result.Group = groupOpt
                        continue</span>
                }

                <span class="cov5" title="19">if strings.HasPrefix(token, "limit:") </span><span class="cov1" title="1">{
                        limit, err := p.parseLimit(token)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">result.Limit = limit
                        continue</span>
                }

                <span class="cov5" title="18">if strings.HasPrefix(token, "view:") </span><span class="cov0" title="0">{
                        result.ViewType = strings.TrimPrefix(token, "view:")
                        continue</span>
                }

                <span class="cov5" title="18">if strings.HasPrefix(token, "cols:") </span><span class="cov0" title="0">{
                        cols, err := p.parseColumns(token)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result.Columns = cols
                        continue</span>
                }

                // Parse filter
                <span class="cov5" title="18">filter, err := p.parseFilter(token)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid filter '%s': %w", token, err)
                }</span>

                <span class="cov5" title="18">result.Filters = append(result.Filters, *filter)</span>
        }

        <span class="cov5" title="14">return result, nil</span>
}

// tokenize splits query string into tokens
func (p *QueryParser) tokenize(query string) []string <span class="cov5" title="14">{
        var tokens []string
        var current strings.Builder
        inParens := 0
        inQuotes := false

        for i, ch := range query </span><span class="cov10" title="263">{
                switch ch </span>{
                case '(':<span class="cov2" title="2">
                        inParens++
                        current.WriteRune(ch)</span>
                case ')':<span class="cov2" title="2">
                        inParens--
                        current.WriteRune(ch)</span>
                case '"':<span class="cov0" title="0">
                        inQuotes = !inQuotes
                        current.WriteRune(ch)</span>
                case ' ':<span class="cov4" title="9">
                        if inParens &gt; 0 || inQuotes </span><span class="cov2" title="2">{
                                current.WriteRune(ch)
                        }</span> else<span class="cov4" title="7"> {
                                if current.Len() &gt; 0 </span><span class="cov4" title="7">{
                                        tokens = append(tokens, current.String())
                                        current.Reset()
                                }</span>
                        }
                default:<span class="cov9" title="250">
                        current.WriteRune(ch)</span>
                }

                // Last character
                <span class="cov10" title="263">if i == len(query)-1 &amp;&amp; current.Len() &gt; 0 </span><span class="cov5" title="13">{
                        tokens = append(tokens, current.String())
                }</span>
        }

        <span class="cov5" title="14">return tokens</span>
}

// parseFilter parses a single filter token
func (p *QueryParser) parseFilter(token string) (*Filter, error) <span class="cov5" title="18">{
        negate := false
        if strings.HasPrefix(token, "-") </span><span class="cov2" title="2">{
                negate = true
                token = token[1:]
        }</span>

        // Pattern: key:value or key:operator:value
        <span class="cov5" title="18">parts := strings.SplitN(token, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid filter format (expected key:value)")
        }</span>

        <span class="cov5" title="18">key := parts[0]
        valueStr := parts[1]

        // Check for comparison operators
        operator := "="
        value := valueStr

        if strings.HasPrefix(valueStr, "&lt;=") </span><span class="cov0" title="0">{
                operator = "&lt;="
                value = strings.TrimPrefix(valueStr, "&lt;=")
        }</span> else<span class="cov5" title="18"> if strings.HasPrefix(valueStr, "&gt;=") </span><span class="cov0" title="0">{
                operator = "&gt;="
                value = strings.TrimPrefix(valueStr, "&gt;=")
        }</span> else<span class="cov5" title="18"> if strings.HasPrefix(valueStr, "&lt;") </span><span class="cov0" title="0">{
                operator = "&lt;"
                value = strings.TrimPrefix(valueStr, "&lt;")
        }</span> else<span class="cov5" title="18"> if strings.HasPrefix(valueStr, "&gt;") </span><span class="cov1" title="1">{
                operator = "&gt;"
                value = strings.TrimPrefix(valueStr, "&gt;")
        }</span>

        // Check for OR values (parentheses)
        <span class="cov5" title="18">if strings.HasPrefix(value, "(") &amp;&amp; strings.HasSuffix(value, ")") </span><span class="cov2" title="2">{
                // Multiple values (OR)
                value = strings.TrimPrefix(value, "(")
                value = strings.TrimSuffix(value, ")")
                values := strings.Split(value, " ")

                // Clean up values
                cleanValues := []string{}
                for _, v := range values </span><span class="cov3" title="4">{
                        v = strings.TrimSpace(v)
                        if v != "" </span><span class="cov3" title="4">{
                                cleanValues = append(cleanValues, v)
                        }</span>
                }

                <span class="cov2" title="2">return &amp;Filter{
                        Key:      key,
                        Operator: "in",
                        Value:    cleanValues,
                        Negate:   negate,
                }, nil</span>
        }

        // Resolve relative dates
        <span class="cov5" title="16">if isDateField(key) </span><span class="cov3" title="4">{
                resolvedValue, err := p.resolveRelativeDate(value)
                if err == nil </span><span class="cov2" title="2">{
                        value = resolvedValue
                }</span>
        }

        <span class="cov5" title="16">return &amp;Filter{
                Key:      key,
                Operator: operator,
                Value:    value,
                Negate:   negate,
        }, nil</span>
}

// parseSort parses sort option
func (p *QueryParser) parseSort(token string) (*SortOption, error) <span class="cov1" title="1">{
        value := strings.TrimPrefix(token, "sort:")

        // Default to ascending
        order := "asc"
        field := value

        if strings.HasSuffix(value, "_desc") </span><span class="cov0" title="0">{
                order = "desc"
                field = strings.TrimSuffix(value, "_desc")
        }</span> else<span class="cov1" title="1"> if strings.HasSuffix(value, "_asc") </span><span class="cov0" title="0">{
                field = strings.TrimSuffix(value, "_asc")
        }</span>

        <span class="cov1" title="1">return &amp;SortOption{
                Field: field,
                Order: order,
        }, nil</span>
}

// parseGroup parses group option
func (p *QueryParser) parseGroup(token string) (*GroupOption, error) <span class="cov0" title="0">{
        value := strings.TrimPrefix(token, "group:")

        return &amp;GroupOption{
                Field: value,
        }, nil
}</span>

// parseLimit parses limit option
func (p *QueryParser) parseLimit(token string) (int, error) <span class="cov1" title="1">{
        value := strings.TrimPrefix(token, "limit:")
        var limit int
        _, err := fmt.Sscanf(value, "%d", &amp;limit)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid limit value")
        }</span>
        <span class="cov1" title="1">return limit, nil</span>
}

// parseColumns parses columns option
func (p *QueryParser) parseColumns(token string) ([]string, error) <span class="cov0" title="0">{
        value := strings.TrimPrefix(token, "cols:")
        value = strings.TrimPrefix(value, "(")
        value = strings.TrimSuffix(value, ")")

        cols := strings.Split(value, " ")
        cleanCols := []string{}
        for _, col := range cols </span><span class="cov0" title="0">{
                col = strings.TrimSpace(col)
                if col != "" </span><span class="cov0" title="0">{
                        cleanCols = append(cleanCols, col)
                }</span>
        }

        <span class="cov0" title="0">return cleanCols, nil</span>
}

// resolveRelativeDate resolves relative date expressions
func (p *QueryParser) resolveRelativeDate(expr string) (string, error) <span class="cov3" title="4">{
        now := time.Now()

        switch expr </span>{
        case "today":<span class="cov1" title="1">
                return now.Format("2006-01-02"), nil</span>
        case "yesterday":<span class="cov0" title="0">
                return now.AddDate(0, 0, -1).Format("2006-01-02"), nil</span>
        case "tomorrow":<span class="cov0" title="0">
                return now.AddDate(0, 0, 1).Format("2006-01-02"), nil</span>
        }

        // this_week, last_week, next_week
        <span class="cov2" title="3">if expr == "this_week" </span><span class="cov1" title="1">{
                // Start of week (Monday)
                weekday := int(now.Weekday())
                if weekday == 0 </span><span class="cov1" title="1">{
                        weekday = 7
                }</span>
                <span class="cov1" title="1">monday := now.AddDate(0, 0, -(weekday - 1))
                return monday.Format("2006-01-02"), nil</span>
        }

        // last_Nd (last N days)
        <span class="cov2" title="2">lastNdPattern := regexp.MustCompile(`^last_(\d+)d$`)
        if matches := lastNdPattern.FindStringSubmatch(expr); matches != nil </span><span class="cov0" title="0">{
                var days int
                fmt.Sscanf(matches[1], "%d", &amp;days)
                return now.AddDate(0, 0, -days).Format("2006-01-02"), nil
        }</span>

        // overdue
        <span class="cov2" title="2">if expr == "overdue" </span><span class="cov0" title="0">{
                return now.Format("2006-01-02"), nil // Will be used with &lt; operator
        }</span>

        <span class="cov2" title="2">return "", fmt.Errorf("unknown relative date: %s", expr)</span>
}

// isDateField checks if a field is a date field
func isDateField(field string) bool <span class="cov5" title="16">{
        dateFields := map[string]bool{
                "due":     true,
                "start":   true,
                "created": true,
                "updated": true,
        }
        return dateFields[field]
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package query

import (
        "fmt"
        "strings"
)

// SQLBuilder builds SQL queries from parsed queries
type SQLBuilder struct{}

// NewSQLBuilder creates a new SQL builder
func NewSQLBuilder() *SQLBuilder <span class="cov6" title="4">{
        return &amp;SQLBuilder{}
}</span>

// BuildResult represents the result of building a SQL query
type BuildResult struct {
        SQL  string
        Args []interface{}
}

// Build builds a SQL query from a parsed query
func (b *SQLBuilder) Build(projectID string, parsed *ParsedQuery) (*BuildResult, error) <span class="cov8" title="8">{
        result := &amp;BuildResult{
                Args: []interface{}{projectID},
        }

        // Base query
        query := "SELECT * FROM tasks WHERE project_id = $1 AND archived_at IS NULL"
        argCount := 1

        // Apply filters
        for _, filter := range parsed.Filters </span><span class="cov9" title="10">{
                condition, args, err := b.buildFilterCondition(filter, &amp;argCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov9" title="10">query += " AND " + condition
                result.Args = append(result.Args, args...)</span>
        }

        // Apply sorting
        <span class="cov8" title="8">if parsed.Sort != nil </span><span class="cov1" title="1">{
                orderClause := b.buildOrderClause(parsed.Sort)
                query += " " + orderClause
        }</span> else<span class="cov8" title="7"> {
                // Default sorting
                query += " ORDER BY created_at DESC"
        }</span>

        // Apply limit
        <span class="cov8" title="8">if parsed.Limit &gt; 0 </span><span class="cov3" title="2">{
                argCount++
                query += fmt.Sprintf(" LIMIT $%d", argCount)
                result.Args = append(result.Args, parsed.Limit)
        }</span>

        <span class="cov8" title="8">result.SQL = query
        return result, nil</span>
}

// buildFilterCondition builds a SQL condition for a filter
func (b *SQLBuilder) buildFilterCondition(filter Filter, argCount *int) (string, []interface{}, error) <span class="cov9" title="10">{
        var args []interface{}

        // Map filter keys to database columns
        dbColumn := b.mapFilterKeyToColumn(filter.Key)

        switch filter.Operator </span>{
        case "=":<span class="cov9" title="10">
                *argCount++
                condition := fmt.Sprintf("%s = $%d", dbColumn, *argCount)
                if filter.Negate </span><span class="cov1" title="1">{
                        condition = fmt.Sprintf("%s != $%d", dbColumn, *argCount)
                }</span>
                <span class="cov9" title="10">args = append(args, filter.Value)
                return condition, args, nil</span>

        case "!=":<span class="cov0" title="0">
                *argCount++
                condition := fmt.Sprintf("%s != $%d", dbColumn, *argCount)
                if filter.Negate </span><span class="cov0" title="0">{
                        condition = fmt.Sprintf("%s = $%d", dbColumn, *argCount)
                }</span>
                <span class="cov0" title="0">args = append(args, filter.Value)
                return condition, args, nil</span>

        case "&gt;", "&lt;", "&gt;=", "&lt;=":<span class="cov0" title="0">
                *argCount++
                operator := filter.Operator
                if filter.Negate </span><span class="cov0" title="0">{
                        // Negate the operator
                        switch operator </span>{
                        case "&gt;":<span class="cov0" title="0">
                                operator = "&lt;="</span>
                        case "&lt;":<span class="cov0" title="0">
                                operator = "&gt;="</span>
                        case "&gt;=":<span class="cov0" title="0">
                                operator = "&lt;"</span>
                        case "&lt;=":<span class="cov0" title="0">
                                operator = "&gt;"</span>
                        }
                }
                <span class="cov0" title="0">condition := fmt.Sprintf("%s %s $%d", dbColumn, operator, *argCount)
                args = append(args, filter.Value)
                return condition, args, nil</span>

        case "in":<span class="cov0" title="0">
                // For array fields or multiple values
                values, ok := filter.Value.([]string)
                if !ok </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("invalid value type for 'in' operator")
                }</span>

                <span class="cov0" title="0">if b.isArrayField(filter.Key) </span><span class="cov0" title="0">{
                        // Array overlap (e.g., assignees, labels)
                        *argCount++
                        condition := fmt.Sprintf("%s &amp;&amp; $%d", dbColumn, *argCount)
                        if filter.Negate </span><span class="cov0" title="0">{
                                condition = fmt.Sprintf("NOT (%s &amp;&amp; $%d)", dbColumn, *argCount)
                        }</span>
                        <span class="cov0" title="0">args = append(args, values)
                        return condition, args, nil</span>
                } else<span class="cov0" title="0"> {
                        // Multiple values (OR)
                        *argCount++
                        condition := fmt.Sprintf("%s = ANY($%d)", dbColumn, *argCount)
                        if filter.Negate </span><span class="cov0" title="0">{
                                condition = fmt.Sprintf("%s != ALL($%d)", dbColumn, *argCount)
                        }</span>
                        <span class="cov0" title="0">args = append(args, values)
                        return condition, args, nil</span>
                }

        default:<span class="cov0" title="0">
                return "", nil, fmt.Errorf("unsupported operator: %s", filter.Operator)</span>
        }
}

// buildOrderClause builds an ORDER BY clause
func (b *SQLBuilder) buildOrderClause(sort *SortOption) string <span class="cov1" title="1">{
        dbColumn := b.mapFilterKeyToColumn(sort.Field)
        order := strings.ToUpper(sort.Order)

        // Handle special cases
        if sort.Field == "priority" </span><span class="cov1" title="1">{
                // Priority should be P0, P1, P2, P3, P4
                if order == "DESC" </span><span class="cov0" title="0">{
                        return "ORDER BY priority ASC" // P0 first
                }</span>
                <span class="cov1" title="1">return "ORDER BY priority DESC"</span> // P4 first
        }

        <span class="cov0" title="0">return fmt.Sprintf("ORDER BY %s %s", dbColumn, order)</span>
}

// mapFilterKeyToColumn maps filter keys to database columns
func (b *SQLBuilder) mapFilterKeyToColumn(key string) string <span class="cov10" title="11">{
        mapping := map[string]string{
                "id":       "id",
                "status":   "status",
                "priority": "priority",
                "assignee": "assignees",
                "label":    "labels",
                "due":      "due_date",
                "start":    "start_date",
                "created":  "created_at",
                "updated":  "updated_at",
                "title":    "title",
        }

        if col, ok := mapping[key]; ok </span><span class="cov10" title="11">{
                return col
        }</span>

        <span class="cov0" title="0">return key</span>
}

// isArrayField checks if a field is an array field
func (b *SQLBuilder) isArrayField(key string) bool <span class="cov0" title="0">{
        arrayFields := map[string]bool{
                "assignee": true,
                "label":    true,
        }
        return arrayFields[key]
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// ProjectRepository handles project data access
type ProjectRepository struct {
        db *sqlx.DB
}

// NewProjectRepository creates a new project repository
func NewProjectRepository(db *sqlx.DB) *ProjectRepository <span class="cov0" title="0">{
        return &amp;ProjectRepository{db: db}
}</span>

// Create creates a new project
func (r *ProjectRepository) Create(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        query := `
                INSERT INTO projects (
                        id, name, description, visibility, settings
                ) VALUES (
                        :id, :name, :description, :visibility, :settings
                )
        `

        _, err := r.db.NamedExecContext(ctx, query, project)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID retrieves a project by ID
func (r *ProjectRepository) GetByID(ctx context.Context, projectID string) (*models.Project, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM projects
                WHERE id = $1 AND archived_at IS NULL
        `

        var project models.Project
        err := r.db.GetContext(ctx, &amp;project, query, projectID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("project not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get project: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// List retrieves all projects
func (r *ProjectRepository) List(ctx context.Context) ([]*models.Project, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM projects
                WHERE archived_at IS NULL
                ORDER BY created_at DESC
        `

        var projects []*models.Project
        err := r.db.SelectContext(ctx, &amp;projects, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list projects: %w", err)
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// Update updates an existing project
func (r *ProjectRepository) Update(ctx context.Context, project *models.Project) error <span class="cov0" title="0">{
        query := `
                UPDATE projects SET
                        name = :name,
                        description = :description,
                        visibility = :visibility,
                        settings = :settings,
                        updated_at = NOW()
                WHERE id = :id
        `

        result, err := r.db.NamedExecContext(ctx, query, project)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update project: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete soft-deletes a project
func (r *ProjectRepository) Delete(ctx context.Context, projectID string) error <span class="cov0" title="0">{
        query := `
                UPDATE projects SET archived_at = NOW()
                WHERE id = $1 AND archived_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete project: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// RevisionRepository handles task revision data access
type RevisionRepository struct {
        db *sqlx.DB
}

// NewRevisionRepository creates a new revision repository
func NewRevisionRepository(db *sqlx.DB) *RevisionRepository <span class="cov0" title="0">{
        return &amp;RevisionRepository{db: db}
}</span>

// GetTaskRevisions retrieves all revisions for a task
func (r *RevisionRepository) GetTaskRevisions(ctx context.Context, taskID string, limit int) ([]*models.TaskRevision, error) <span class="cov0" title="0">{
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">query := `
                SELECT * FROM task_revisions
                WHERE task_id = $1
                ORDER BY created_at DESC
                LIMIT $2
        `

        var revisions []*models.TaskRevision
        err := r.db.SelectContext(ctx, &amp;revisions, query, taskID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get revisions: %w", err)
        }</span>

        <span class="cov0" title="0">return revisions, nil</span>
}

// GetRevisionByID retrieves a specific revision
func (r *RevisionRepository) GetRevisionByID(ctx context.Context, revID int64) (*models.TaskRevision, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM task_revisions
                WHERE rev_id = $1
        `

        var revision models.TaskRevision
        err := r.db.GetContext(ctx, &amp;revision, query, revID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get revision: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;revision, nil</span>
}

// GetRevisionCount returns the total number of revisions for a task
func (r *RevisionRepository) GetRevisionCount(ctx context.Context, taskID string) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM task_revisions
                WHERE task_id = $1
        `

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count revisions: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetLatestRevision retrieves the latest revision for a task
func (r *RevisionRepository) GetLatestRevision(ctx context.Context, taskID string) (*models.TaskRevision, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM task_revisions
                WHERE task_id = $1
                ORDER BY created_at DESC
                LIMIT 1
        `

        var revision models.TaskRevision
        err := r.db.GetContext(ctx, &amp;revision, query, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get latest revision: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;revision, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// TaskRepository handles task data access
type TaskRepository struct {
        db *sqlx.DB
}

// NewTaskRepository creates a new task repository
func NewTaskRepository(db *sqlx.DB) *TaskRepository <span class="cov0" title="0">{
        return &amp;TaskRepository{db: db}
}</span>

// Create creates a new task
func (r *TaskRepository) Create(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        query := `
                INSERT INTO tasks (
                        id, project_id, title, status, priority,
                        assignees, labels, start_date, due_date,
                        markdown_body, extra_meta, created_by, updated_by
                ) VALUES (
                        :id, :project_id, :title, :status, :priority,
                        :assignees, :labels, :start_date, :due_date,
                        :markdown_body, :extra_meta, :created_by, :updated_by
                )
        `

        _, err := r.db.NamedExecContext(ctx, query, task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID retrieves a task by ID
func (r *TaskRepository) GetByID(ctx context.Context, projectID, taskID string) (*models.Task, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM tasks
                WHERE id = $1 AND project_id = $2 AND archived_at IS NULL
        `

        var task models.Task
        err := r.db.GetContext(ctx, &amp;task, query, taskID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("task not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get task: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;task, nil</span>
}

// List retrieves all tasks for a project
func (r *TaskRepository) List(ctx context.Context, projectID string, filters *TaskFilters) ([]*models.Task, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM tasks
                WHERE project_id = $1 AND archived_at IS NULL
        `
        args := []interface{}{projectID}
        argCount := 1

        // Apply filters
        if filters != nil </span><span class="cov0" title="0">{
                if len(filters.Statuses) &gt; 0 </span><span class="cov0" title="0">{
                        argCount++
                        query += fmt.Sprintf(" AND status = ANY($%d)", argCount)
                        args = append(args, filters.Statuses)
                }</span>

                <span class="cov0" title="0">if len(filters.Priorities) &gt; 0 </span><span class="cov0" title="0">{
                        argCount++
                        query += fmt.Sprintf(" AND priority = ANY($%d)", argCount)
                        args = append(args, filters.Priorities)
                }</span>

                <span class="cov0" title="0">if len(filters.Assignees) &gt; 0 </span><span class="cov0" title="0">{
                        argCount++
                        query += fmt.Sprintf(" AND assignees &amp;&amp; $%d", argCount)
                        args = append(args, filters.Assignees)
                }</span>

                <span class="cov0" title="0">if len(filters.Labels) &gt; 0 </span><span class="cov0" title="0">{
                        argCount++
                        query += fmt.Sprintf(" AND labels &amp;&amp; $%d", argCount)
                        args = append(args, filters.Labels)
                }</span>
        }

        // Default ordering
        <span class="cov0" title="0">query += " ORDER BY created_at DESC"

        // Apply limit
        if filters != nil &amp;&amp; filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" LIMIT $%d", argCount)
                args = append(args, filters.Limit)
        }</span>

        <span class="cov0" title="0">var tasks []*models.Task
        err := r.db.SelectContext(ctx, &amp;tasks, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// Update updates an existing task
func (r *TaskRepository) Update(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        query := `
                UPDATE tasks SET
                        title = :title,
                        status = :status,
                        priority = :priority,
                        assignees = :assignees,
                        labels = :labels,
                        start_date = :start_date,
                        due_date = :due_date,
                        markdown_body = :markdown_body,
                        extra_meta = :extra_meta,
                        updated_by = :updated_by,
                        updated_at = NOW()
                WHERE id = :id AND project_id = :project_id
        `

        result, err := r.db.NamedExecContext(ctx, query, task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete soft-deletes a task (sets archived_at)
func (r *TaskRepository) Delete(ctx context.Context, projectID, taskID string) error <span class="cov0" title="0">{
        query := `
                UPDATE tasks SET archived_at = NOW()
                WHERE id = $1 AND project_id = $2 AND archived_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, taskID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete task: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Search performs full-text search on tasks
func (r *TaskRepository) Search(ctx context.Context, projectID, searchQuery string, limit int) ([]*models.Task, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM tasks
                WHERE project_id = $1
                        AND archived_at IS NULL
                        AND search_vector @@ to_tsquery('english', $2)
                ORDER BY ts_rank(search_vector, to_tsquery('english', $2)) DESC
                LIMIT $3
        `

        var tasks []*models.Task
        err := r.db.SelectContext(ctx, &amp;tasks, query, projectID, searchQuery, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// TaskFilters represents filters for task listing
type TaskFilters struct {
        Statuses   []string
        Priorities []string
        Assignees  []string
        Labels     []string
        Limit      int
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// UserRepository handles user data access
type UserRepository struct {
        db *sqlx.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *sqlx.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

// Create creates a new user
func (r *UserRepository) Create(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (
                        id, email, name, avatar_url, password_hash, preferences
                ) VALUES (
                        :id, :email, :name, :avatar_url, :password_hash, :preferences
                )
        `

        _, err := r.db.NamedExecContext(ctx, query, user)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID retrieves a user by ID
func (r *UserRepository) GetByID(ctx context.Context, userID string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM users WHERE id = $1
        `

        var user models.User
        err := r.db.GetContext(ctx, &amp;user, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByEmail retrieves a user by email
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM users WHERE email = $1
        `

        var user models.User
        err := r.db.GetContext(ctx, &amp;user, query, email)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// UpdateLastLogin updates the last login timestamp
func (r *UserRepository) UpdateLastLogin(ctx context.Context, userID string) error <span class="cov0" title="0">{
        query := `
                UPDATE users SET last_login_at = NOW() WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, userID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// ViewRepository handles saved view data access
type ViewRepository struct {
        db *sqlx.DB
}

// NewViewRepository creates a new view repository
func NewViewRepository(db *sqlx.DB) *ViewRepository <span class="cov0" title="0">{
        return &amp;ViewRepository{db: db}
}</span>

// Create creates a new saved view
func (r *ViewRepository) Create(ctx context.Context, view *models.SavedView) error <span class="cov0" title="0">{
        query := `
                INSERT INTO saved_views (
                        id, project_id, owner_user_id, name, description,
                        scope, raw_query, normalized_query, presentation
                ) VALUES (
                        :id, :project_id, :owner_user_id, :name, :description,
                        :scope, :raw_query, :normalized_query, :presentation
                )
        `

        _, err := r.db.NamedExecContext(ctx, query, view)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create view: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByID retrieves a view by ID
func (r *ViewRepository) GetByID(ctx context.Context, projectID, viewID string) (*models.SavedView, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM saved_views
                WHERE id = $1 AND project_id = $2
        `

        var view models.SavedView
        err := r.db.GetContext(ctx, &amp;view, query, viewID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("view not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get view: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;view, nil</span>
}

// List retrieves all views for a project
func (r *ViewRepository) List(ctx context.Context, projectID string, ownerUserID *string) ([]*models.SavedView, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM saved_views
                WHERE project_id = $1
                        AND (scope = 'shared' OR owner_user_id = $2)
                ORDER BY use_count DESC, created_at DESC
        `

        var views []*models.SavedView
        err := r.db.SelectContext(ctx, &amp;views, query, projectID, ownerUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list views: %w", err)
        }</span>

        <span class="cov0" title="0">return views, nil</span>
}

// Update updates an existing view
func (r *ViewRepository) Update(ctx context.Context, view *models.SavedView) error <span class="cov0" title="0">{
        query := `
                UPDATE saved_views SET
                        name = :name,
                        description = :description,
                        scope = :scope,
                        raw_query = :raw_query,
                        normalized_query = :normalized_query,
                        presentation = :presentation,
                        updated_at = NOW()
                WHERE id = :id AND project_id = :project_id
        `

        result, err := r.db.NamedExecContext(ctx, query, view)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update view: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("view not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a view
func (r *ViewRepository) Delete(ctx context.Context, projectID, viewID string) error <span class="cov0" title="0">{
        query := `
                DELETE FROM saved_views
                WHERE id = $1 AND project_id = $2
        `

        result, err := r.db.ExecContext(ctx, query, viewID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete view: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("view not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IncrementUseCount increments the use count of a view
func (r *ViewRepository) IncrementUseCount(ctx context.Context, viewID string) error <span class="cov0" title="0">{
        query := `
                UPDATE saved_views SET
                        use_count = use_count + 1,
                        last_used_at = NOW()
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, viewID)
        return err
}</span>

// ExecuteQuery executes a saved view's query and returns tasks
func (r *ViewRepository) ExecuteQuery(ctx context.Context, sql string, args []interface{}) ([]*models.Task, error) <span class="cov0" title="0">{
        var tasks []*models.Task
        err := r.db.SelectContext(ctx, &amp;tasks, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package search

import (
        "context"
        "fmt"
        "time"

        "github.com/meilisearch/meilisearch-go"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
)

// MeilisearchClient wraps Meilisearch client
type MeilisearchClient struct {
        client *meilisearch.Client
        index  string
}

// TaskDocument represents a task document in Meilisearch
type TaskDocument struct {
        ID           string   `json:"id"`
        ProjectID    string   `json:"project_id"`
        Title        string   `json:"title"`
        Status       string   `json:"status"`
        Priority     string   `json:"priority"`
        Assignees    []string `json:"assignees"`
        Labels       []string `json:"labels"`
        MarkdownBody string   `json:"markdown_body"`
        DueDate      *int64   `json:"due_date,omitempty"`      // Unix timestamp
        StartDate    *int64   `json:"start_date,omitempty"`    // Unix timestamp
        CreatedAt    int64    `json:"created_at"`              // Unix timestamp
        UpdatedAt    int64    `json:"updated_at"`              // Unix timestamp
}

// SearchResult represents a search result
type SearchResult struct {
        Hits       []TaskDocument        `json:"hits"`
        TotalHits  int64                 `json:"total_hits"`
        Query      string                `json:"query"`
        Processing time.Duration         `json:"processing_time_ms"`
}

// NewMeilisearchClient creates a new Meilisearch client
func NewMeilisearchClient(host, apiKey, index string) (*MeilisearchClient, error) <span class="cov0" title="0">{
        client := meilisearch.NewClient(meilisearch.ClientConfig{
                Host:   host,
                APIKey: apiKey,
        })

        mc := &amp;MeilisearchClient{
                client: client,
                index:  index,
        }

        // Create index if it doesn't exist
        if err := mc.setupIndex(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to setup index: %w", err)
        }</span>

        <span class="cov0" title="0">return mc, nil</span>
}

// setupIndex sets up the Meilisearch index with proper configuration
func (mc *MeilisearchClient) setupIndex() error <span class="cov0" title="0">{
        _ = context.Background()

        // Create index if it doesn't exist
        _, err := mc.client.CreateIndex(&amp;meilisearch.IndexConfig{
                Uid:        mc.index,
                PrimaryKey: "id",
        })
        if err != nil </span><span class="cov0" title="0">{
                // Ignore error if index already exists
                if !isMeilisearchIndexExistsError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create index: %w", err)
                }</span>
        }

        // Get index
        <span class="cov0" title="0">index := mc.client.Index(mc.index)

        // Configure searchable attributes
        _, err = index.UpdateSearchableAttributes(&amp;[]string{
                "title",
                "markdown_body",
                "labels",
                "id",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update searchable attributes: %w", err)
        }</span>

        // Configure filterable attributes
        <span class="cov0" title="0">_, err = index.UpdateFilterableAttributes(&amp;[]string{
                "project_id",
                "status",
                "priority",
                "assignees",
                "labels",
                "due_date",
                "start_date",
                "created_at",
                "updated_at",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update filterable attributes: %w", err)
        }</span>

        // Configure sortable attributes
        <span class="cov0" title="0">_, err = index.UpdateSortableAttributes(&amp;[]string{
                "created_at",
                "updated_at",
                "due_date",
                "start_date",
                "priority",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update sortable attributes: %w", err)
        }</span>

        // Configure ranking rules
        <span class="cov0" title="0">_, err = index.UpdateRankingRules(&amp;[]string{
                "words",
                "typo",
                "proximity",
                "attribute",
                "sort",
                "exactness",
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update ranking rules: %w", err)
        }</span>

        // Wait for tasks to complete
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        return nil</span>
}

// IndexTask indexes a task in Meilisearch
func (mc *MeilisearchClient) IndexTask(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        doc := mc.taskToDocument(task)

        index := mc.client.Index(mc.index)
        _, err := index.AddDocuments([]TaskDocument{doc})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to index task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IndexTasks indexes multiple tasks in batch
func (mc *MeilisearchClient) IndexTasks(ctx context.Context, tasks []*models.Task) error <span class="cov0" title="0">{
        if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">docs := make([]TaskDocument, len(tasks))
        for i, task := range tasks </span><span class="cov0" title="0">{
                docs[i] = mc.taskToDocument(task)
        }</span>

        <span class="cov0" title="0">index := mc.client.Index(mc.index)
        _, err := index.AddDocuments(docs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to index tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTask updates a task in Meilisearch
func (mc *MeilisearchClient) UpdateTask(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        return mc.IndexTask(ctx, task) // Meilisearch upserts by default
}</span>

// DeleteTask deletes a task from Meilisearch
func (mc *MeilisearchClient) DeleteTask(ctx context.Context, taskID string) error <span class="cov0" title="0">{
        index := mc.client.Index(mc.index)
        _, err := index.DeleteDocument(taskID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Search performs a search query
func (mc *MeilisearchClient) Search(ctx context.Context, query string, projectID string, limit int, filters map[string]interface{}) (*SearchResult, error) <span class="cov0" title="0">{
        index := mc.client.Index(mc.index)

        // Build filter string
        filterStr := fmt.Sprintf("project_id = %s", projectID)

        if status, ok := filters["status"].(string); ok &amp;&amp; status != "" </span><span class="cov0" title="0">{
                filterStr += fmt.Sprintf(" AND status = %s", status)
        }</span>

        <span class="cov0" title="0">if priority, ok := filters["priority"].(string); ok &amp;&amp; priority != "" </span><span class="cov0" title="0">{
                filterStr += fmt.Sprintf(" AND priority = %s", priority)
        }</span>

        <span class="cov0" title="0">if assignees, ok := filters["assignees"].([]string); ok &amp;&amp; len(assignees) &gt; 0 </span><span class="cov0" title="0">{
                for _, assignee := range assignees </span><span class="cov0" title="0">{
                        filterStr += fmt.Sprintf(" AND assignees = %s", assignee)
                }</span>
        }

        <span class="cov0" title="0">if limit == 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        // Perform search
        <span class="cov0" title="0">searchRes, err := index.Search(query, &amp;meilisearch.SearchRequest{
                Limit:  int64(limit),
                Filter: filterStr,
                AttributesToHighlight: []string{"title", "markdown_body"},
                HighlightPreTag:  "&lt;mark&gt;",
                HighlightPostTag: "&lt;/mark&gt;",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search: %w", err)
        }</span>

        // Convert results
        <span class="cov0" title="0">hits := make([]TaskDocument, 0, len(searchRes.Hits))
        for _, hit := range searchRes.Hits </span><span class="cov0" title="0">{
                // Type assertion
                hitMap, ok := hit.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">doc := TaskDocument{
                        ID:           getStringField(hitMap, "id"),
                        ProjectID:    getStringField(hitMap, "project_id"),
                        Title:        getStringField(hitMap, "title"),
                        Status:       getStringField(hitMap, "status"),
                        Priority:     getStringField(hitMap, "priority"),
                        MarkdownBody: getStringField(hitMap, "markdown_body"),
                }

                if assignees, ok := hitMap["assignees"].([]interface{}); ok </span><span class="cov0" title="0">{
                        doc.Assignees = make([]string, len(assignees))
                        for i, a := range assignees </span><span class="cov0" title="0">{
                                if s, ok := a.(string); ok </span><span class="cov0" title="0">{
                                        doc.Assignees[i] = s
                                }</span>
                        }
                }

                <span class="cov0" title="0">if labels, ok := hitMap["labels"].([]interface{}); ok </span><span class="cov0" title="0">{
                        doc.Labels = make([]string, len(labels))
                        for i, l := range labels </span><span class="cov0" title="0">{
                                if s, ok := l.(string); ok </span><span class="cov0" title="0">{
                                        doc.Labels[i] = s
                                }</span>
                        }
                }

                <span class="cov0" title="0">hits = append(hits, doc)</span>
        }

        <span class="cov0" title="0">return &amp;SearchResult{
                Hits:       hits,
                TotalHits:  searchRes.EstimatedTotalHits,
                Query:      query,
                Processing: time.Duration(searchRes.ProcessingTimeMs) * time.Millisecond,
        }, nil</span>
}

// HealthCheck checks if Meilisearch is healthy
func (mc *MeilisearchClient) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        _, err := mc.client.Health()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("meilisearch health check failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// taskToDocument converts a task model to a search document
func (mc *MeilisearchClient) taskToDocument(task *models.Task) TaskDocument <span class="cov0" title="0">{
        doc := TaskDocument{
                ID:           task.ID,
                ProjectID:    task.ProjectID,
                Title:        task.Title,
                Status:       string(task.Status),
                Priority:     string(task.Priority),
                Assignees:    task.Assignees,
                Labels:       task.Labels,
                MarkdownBody: task.MarkdownBody,
                CreatedAt:    task.CreatedAt.Unix(),
                UpdatedAt:    task.UpdatedAt.Unix(),
        }

        if task.DueDate != nil </span><span class="cov0" title="0">{
                timestamp := task.DueDate.Unix()
                doc.DueDate = &amp;timestamp
        }</span>

        <span class="cov0" title="0">if task.StartDate != nil </span><span class="cov0" title="0">{
                timestamp := task.StartDate.Unix()
                doc.StartDate = &amp;timestamp
        }</span>

        <span class="cov0" title="0">return doc</span>
}

// Helper functions

func isMeilisearchIndexExistsError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check if error message contains "index_already_exists"
        <span class="cov0" title="0">return false</span> // Simplified for now
}

func getStringField(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if v, ok := m[key].(string); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/tktomaru/taskai/taskai-server/internal/auth"
        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
)

// AuthService handles authentication business logic
type AuthService struct {
        userRepo       *repository.UserRepository
        passwordHasher *auth.PasswordHasher
        jwtManager     *auth.JWTManager
}

// NewAuthService creates a new auth service
func NewAuthService(userRepo *repository.UserRepository, jwtSecret string, jwtExpiresIn time.Duration) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                userRepo:       userRepo,
                passwordHasher: auth.NewPasswordHasher(),
                jwtManager:     auth.NewJWTManager(jwtSecret, jwtExpiresIn),
        }
}</span>

// RegisterRequest represents a user registration request
type RegisterRequest struct {
        ID       string `json:"id"`
        Email    string `json:"email"`
        Name     string `json:"name"`
        Password string `json:"password"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// AuthResponse represents an authentication response
type AuthResponse struct {
        User  *models.User `json:"user"`
        Token string       `json:"token"`
}

// Register registers a new user
func (s *AuthService) Register(ctx context.Context, req *RegisterRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        // Validate input
        if req.Email == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("email is required")
        }</span>
        <span class="cov0" title="0">if req.Password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password is required")
        }</span>
        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("name is required")
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">existingUser, _ := s.userRepo.GetByEmail(ctx, req.Email)
        if existingUser != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with this email already exists")
        }</span>

        // Hash password
        <span class="cov0" title="0">passwordHash, err := s.passwordHasher.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create user
        <span class="cov0" title="0">user := &amp;models.User{
                ID:           req.ID,
                Email:        req.Email,
                Name:         req.Name,
                PasswordHash: &amp;passwordHash,
                Preferences:  make(models.JSONB),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.userRepo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := s.jwtManager.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Update last login
        <span class="cov0" title="0">_ = s.userRepo.UpdateLastLogin(ctx, user.ID)

        // Remove password hash from response
        user.PasswordHash = nil

        return &amp;AuthResponse{
                User:  user,
                Token: token,
        }, nil</span>
}

// Login authenticates a user
func (s *AuthService) Login(ctx context.Context, req *LoginRequest) (*AuthResponse, error) <span class="cov0" title="0">{
        // Get user by email
        user, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid email or password")
        }</span>

        // Verify password
        <span class="cov0" title="0">if user.PasswordHash == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password authentication not enabled for this user")
        }</span>

        <span class="cov0" title="0">valid, err := s.passwordHasher.VerifyPassword(req.Password, *user.PasswordHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify password: %w", err)
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid email or password")
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := s.jwtManager.GenerateToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Update last login
        <span class="cov0" title="0">_ = s.userRepo.UpdateLastLogin(ctx, user.ID)

        // Remove password hash from response
        user.PasswordHash = nil

        return &amp;AuthResponse{
                User:  user,
                Token: token,
        }, nil</span>
}

// ValidateToken validates a JWT token and returns the user
func (s *AuthService) ValidateToken(tokenString string) (*models.User, error) <span class="cov0" title="0">{
        claims, err := s.jwtManager.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(context.Background(), claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        // Remove password hash
        <span class="cov0" title="0">user.PasswordHash = nil

        return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *AuthService) GetUserByID(ctx context.Context, userID string) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Remove password hash
        <span class="cov0" title="0">user.PasswordHash = nil

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
)

// ProjectService handles project business logic
type ProjectService struct {
        repo *repository.ProjectRepository
}

// NewProjectService creates a new project service
func NewProjectService(repo *repository.ProjectRepository) *ProjectService <span class="cov0" title="0">{
        return &amp;ProjectService{repo: repo}
}</span>

// CreateProjectRequest represents a request to create a project
type CreateProjectRequest struct {
        ID          string                  `json:"id"`
        Name        string                  `json:"name"`
        Description string                  `json:"description"`
        Visibility  models.ProjectVisibility `json:"visibility"`
}

// UpdateProjectRequest represents a request to update a project
type UpdateProjectRequest struct {
        Name        string                  `json:"name"`
        Description string                  `json:"description"`
        Visibility  models.ProjectVisibility `json:"visibility"`
}

// Create creates a new project
func (s *ProjectService) Create(ctx context.Context, req *CreateProjectRequest) (*models.Project, error) <span class="cov0" title="0">{
        if req.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>

        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project name is required")
        }</span>

        <span class="cov0" title="0">project := &amp;models.Project{
                ID:          req.ID,
                Name:        req.Name,
                Description: &amp;req.Description,
                Visibility:  req.Visibility,
                Settings:    make(models.JSONB),
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.repo.Create(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return project, nil</span>
}

// GetByID retrieves a project by ID
func (s *ProjectService) GetByID(ctx context.Context, projectID string) (*models.Project, error) <span class="cov0" title="0">{
        return s.repo.GetByID(ctx, projectID)
}</span>

// List retrieves all projects
func (s *ProjectService) List(ctx context.Context) ([]*models.Project, error) <span class="cov0" title="0">{
        return s.repo.List(ctx)
}</span>

// Update updates an existing project
func (s *ProjectService) Update(ctx context.Context, projectID string, req *UpdateProjectRequest) (*models.Project, error) <span class="cov0" title="0">{
        // Get existing project
        project, err := s.repo.GetByID(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">project.Name = req.Name
        project.Description = &amp;req.Description
        project.Visibility = req.Visibility

        if err := s.repo.Update(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return project, nil</span>
}

// Delete deletes a project
func (s *ProjectService) Delete(ctx context.Context, projectID string) error <span class="cov0" title="0">{
        return s.repo.Delete(ctx, projectID)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "context"
        "fmt"
        "strings"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
)

// RevisionService handles revision business logic
type RevisionService struct {
        revisionRepo *repository.RevisionRepository
        taskRepo     *repository.TaskRepository
}

// NewRevisionService creates a new revision service
func NewRevisionService(revisionRepo *repository.RevisionRepository, taskRepo *repository.TaskRepository) *RevisionService <span class="cov0" title="0">{
        return &amp;RevisionService{
                revisionRepo: revisionRepo,
                taskRepo:     taskRepo,
        }
}</span>

// RevisionResponse represents a revision with additional metadata
type RevisionResponse struct {
        Revision      *models.TaskRevision `json:"revision"`
        RevisionIndex int                  `json:"revision_index"` // 1-based index (1 = oldest, N = newest)
        TotalCount    int                  `json:"total_count"`
}

// RevisionDiff represents differences between two revisions
type RevisionDiff struct {
        OldRevision *models.TaskRevision `json:"old_revision"`
        NewRevision *models.TaskRevision `json:"new_revision"`
        Changes     []FieldChange        `json:"changes"`
}

// FieldChange represents a change in a specific field
type FieldChange struct {
        Field    string      `json:"field"`
        OldValue interface{} `json:"old_value"`
        NewValue interface{} `json:"new_value"`
        Type     string      `json:"type"` // "modified", "added", "removed"
}

// GetTaskRevisions retrieves all revisions for a task
func (s *RevisionService) GetTaskRevisions(ctx context.Context, taskID string, limit int) ([]*RevisionResponse, error) <span class="cov0" title="0">{
        revisions, err := s.revisionRepo.GetTaskRevisions(ctx, taskID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">totalCount, err := s.revisionRepo.GetRevisionCount(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                totalCount = len(revisions)
        }</span>

        // Build response with indexes (oldest = 1, newest = N)
        <span class="cov0" title="0">responses := make([]*RevisionResponse, len(revisions))
        for i, rev := range revisions </span><span class="cov0" title="0">{
                responses[i] = &amp;RevisionResponse{
                        Revision:      rev,
                        RevisionIndex: totalCount - i,
                        TotalCount:    totalCount,
                }
        }</span>

        <span class="cov0" title="0">return responses, nil</span>
}

// GetRevision retrieves a specific revision
func (s *RevisionService) GetRevision(ctx context.Context, revID int64) (*models.TaskRevision, error) <span class="cov0" title="0">{
        return s.revisionRepo.GetRevisionByID(ctx, revID)
}</span>

// CompareRevisions compares two revisions and returns the differences
func (s *RevisionService) CompareRevisions(ctx context.Context, oldRevID, newRevID int64) (*RevisionDiff, error) <span class="cov0" title="0">{
        oldRev, err := s.revisionRepo.GetRevisionByID(ctx, oldRevID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get old revision: %w", err)
        }</span>

        <span class="cov0" title="0">newRev, err := s.revisionRepo.GetRevisionByID(ctx, newRevID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get new revision: %w", err)
        }</span>

        <span class="cov0" title="0">if oldRev.TaskID != newRev.TaskID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("revisions belong to different tasks")
        }</span>

        <span class="cov0" title="0">changes := s.calculateChanges(oldRev, newRev)

        return &amp;RevisionDiff{
                OldRevision: oldRev,
                NewRevision: newRev,
                Changes:     changes,
        }, nil</span>
}

// CompareWithCurrent compares a revision with the current task state
func (s *RevisionService) CompareWithCurrent(ctx context.Context, projectID, taskID string, revID int64) (*RevisionDiff, error) <span class="cov0" title="0">{
        oldRev, err := s.revisionRepo.GetRevisionByID(ctx, revID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get revision: %w", err)
        }</span>

        <span class="cov0" title="0">currentTask, err := s.taskRepo.GetByID(ctx, projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current task: %w", err)
        }</span>

        // Convert current task to revision format for comparison
        <span class="cov0" title="0">currentRev := &amp;models.TaskRevision{
                TaskID:       currentTask.ID,
                MarkdownBody: currentTask.MarkdownBody,
                MetaSnapshot: make(models.JSONB),
        }

        // Build meta snapshot
        currentRev.MetaSnapshot["title"] = currentTask.Title
        currentRev.MetaSnapshot["status"] = currentTask.Status
        currentRev.MetaSnapshot["priority"] = currentTask.Priority
        currentRev.MetaSnapshot["assignees"] = currentTask.Assignees
        currentRev.MetaSnapshot["labels"] = currentTask.Labels
        if currentTask.DueDate != nil </span><span class="cov0" title="0">{
                currentRev.MetaSnapshot["due_date"] = currentTask.DueDate
        }</span>
        <span class="cov0" title="0">if currentTask.StartDate != nil </span><span class="cov0" title="0">{
                currentRev.MetaSnapshot["start_date"] = currentTask.StartDate
        }</span>

        <span class="cov0" title="0">changes := s.calculateChanges(oldRev, currentRev)

        return &amp;RevisionDiff{
                OldRevision: oldRev,
                NewRevision: currentRev,
                Changes:     changes,
        }, nil</span>
}

// calculateChanges calculates the changes between two revisions
func (s *RevisionService) calculateChanges(oldRev, newRev *models.TaskRevision) []FieldChange <span class="cov5" title="6">{
        var changes []FieldChange

        // Compare markdown body
        if oldRev.MarkdownBody != newRev.MarkdownBody </span><span class="cov2" title="2">{
                changes = append(changes, FieldChange{
                        Field:    "markdown_body",
                        OldValue: oldRev.MarkdownBody,
                        NewValue: newRev.MarkdownBody,
                        Type:     "modified",
                })
        }</span>

        // Compare metadata fields
        <span class="cov5" title="6">metaFields := []string{"title", "status", "priority", "assignees", "labels", "due_date", "start_date"}

        for _, field := range metaFields </span><span class="cov10" title="42">{
                oldVal, oldExists := oldRev.MetaSnapshot[field]
                newVal, newExists := newRev.MetaSnapshot[field]

                if !oldExists &amp;&amp; newExists </span><span class="cov1" title="1">{
                        changes = append(changes, FieldChange{
                                Field:    field,
                                OldValue: nil,
                                NewValue: newVal,
                                Type:     "added",
                        })
                }</span> else<span class="cov9" title="41"> if oldExists &amp;&amp; !newExists </span><span class="cov1" title="1">{
                        changes = append(changes, FieldChange{
                                Field:    field,
                                OldValue: oldVal,
                                NewValue: nil,
                                Type:     "removed",
                        })
                }</span> else<span class="cov9" title="40"> if oldExists &amp;&amp; newExists </span><span class="cov6" title="10">{
                        // Compare values
                        if !s.valuesEqual(oldVal, newVal) </span><span class="cov3" title="3">{
                                changes = append(changes, FieldChange{
                                        Field:    field,
                                        OldValue: oldVal,
                                        NewValue: newVal,
                                        Type:     "modified",
                                })
                        }</span>
                }
        }

        <span class="cov5" title="6">return changes</span>
}

// valuesEqual compares two values for equality
func (s *RevisionService) valuesEqual(a, b interface{}) bool <span class="cov7" title="16">{
        // Simple string comparison for now
        return fmt.Sprint(a) == fmt.Sprint(b)
}</span>

// GenerateTextDiff generates a unified diff for markdown body changes
func (s *RevisionService) GenerateTextDiff(oldText, newText string) string <span class="cov4" title="4">{
        // Simple line-by-line diff
        oldLines := strings.Split(oldText, "\n")
        newLines := strings.Split(newText, "\n")

        var diff strings.Builder
        diff.WriteString("--- Old\n")
        diff.WriteString("+++ New\n")

        // Very simple diff implementation
        maxLen := len(oldLines)
        if len(newLines) &gt; maxLen </span><span class="cov1" title="1">{
                maxLen = len(newLines)
        }</span>

        <span class="cov4" title="4">for i := 0; i &lt; maxLen; i++ </span><span class="cov6" title="12">{
                var oldLine, newLine string
                if i &lt; len(oldLines) </span><span class="cov6" title="11">{
                        oldLine = oldLines[i]
                }</span>
                <span class="cov6" title="12">if i &lt; len(newLines) </span><span class="cov6" title="11">{
                        newLine = newLines[i]
                }</span>

                <span class="cov6" title="12">if oldLine != newLine </span><span class="cov4" title="4">{
                        if oldLine != "" </span><span class="cov3" title="3">{
                                diff.WriteString(fmt.Sprintf("- %s\n", oldLine))
                        }</span>
                        <span class="cov4" title="4">if newLine != "" </span><span class="cov3" title="3">{
                                diff.WriteString(fmt.Sprintf("+ %s\n", newLine))
                        }</span>
                } else<span class="cov6" title="8"> {
                        diff.WriteString(fmt.Sprintf("  %s\n", oldLine))
                }</span>
        }

        <span class="cov4" title="4">return diff.String()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
        "github.com/tktomaru/taskai/taskai-server/internal/search"
)

// SearchService handles search operations
type SearchService struct {
        taskRepo *repository.TaskRepository
        meili    *search.MeilisearchClient
}

// NewSearchService creates a new search service
func NewSearchService(taskRepo *repository.TaskRepository, meili *search.MeilisearchClient) *SearchService <span class="cov0" title="0">{
        return &amp;SearchService{
                taskRepo: taskRepo,
                meili:    meili,
        }
}</span>

// SearchRequest represents a search request
type SearchRequest struct {
        Query     string            `json:"query"`
        ProjectID string            `json:"project_id"`
        Limit     int               `json:"limit"`
        Filters   map[string]interface{} `json:"filters"`
}

// SearchResponse represents a search response
type SearchResponse struct {
        Results []*models.Task `json:"results"`
        Total   int64          `json:"total"`
        Query   string         `json:"query"`
}

// Search performs a full-text search
func (s *SearchService) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) <span class="cov0" title="0">{
        if s.meili == nil </span><span class="cov0" title="0">{
                // Fallback to PostgreSQL full-text search
                return s.fallbackSearch(ctx, req)
        }</span>

        // Use Meilisearch
        <span class="cov0" title="0">result, err := s.meili.Search(ctx, req.Query, req.ProjectID, req.Limit, req.Filters)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback on error
                return s.fallbackSearch(ctx, req)
        }</span>

        // Convert search results to task models
        <span class="cov0" title="0">tasks := make([]*models.Task, 0, len(result.Hits))
        for _, hit := range result.Hits </span><span class="cov0" title="0">{
                // Fetch full task from database
                task, err := s.taskRepo.GetByID(ctx, hit.ProjectID, hit.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tasks = append(tasks, task)</span>
        }

        <span class="cov0" title="0">return &amp;SearchResponse{
                Results: tasks,
                Total:   result.TotalHits,
                Query:   req.Query,
        }, nil</span>
}

// IndexTask indexes a task in the search engine
func (s *SearchService) IndexTask(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        if s.meili == nil </span><span class="cov0" title="0">{
                return nil // Skip if Meilisearch is not configured
        }</span>

        <span class="cov0" title="0">return s.meili.IndexTask(ctx, task)</span>
}

// UpdateTaskIndex updates a task in the search engine
func (s *SearchService) UpdateTaskIndex(ctx context.Context, task *models.Task) error <span class="cov0" title="0">{
        if s.meili == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.meili.UpdateTask(ctx, task)</span>
}

// DeleteTaskIndex removes a task from the search engine
func (s *SearchService) DeleteTaskIndex(ctx context.Context, taskID string) error <span class="cov0" title="0">{
        if s.meili == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.meili.DeleteTask(ctx, taskID)</span>
}

// ReindexAll reindexes all tasks for a project
func (s *SearchService) ReindexAll(ctx context.Context, projectID string) error <span class="cov0" title="0">{
        if s.meili == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("meilisearch not configured")
        }</span>

        // Get all tasks
        <span class="cov0" title="0">tasks, err := s.taskRepo.List(ctx, projectID, &amp;repository.TaskFilters{
                Limit: 10000, // Large limit
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch tasks: %w", err)
        }</span>

        // Index in batches
        <span class="cov0" title="0">batchSize := 100
        for i := 0; i &lt; len(tasks); i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; len(tasks) </span><span class="cov0" title="0">{
                        end = len(tasks)
                }</span>

                <span class="cov0" title="0">batch := tasks[i:end]
                if err := s.meili.IndexTasks(ctx, batch); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to index batch: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// fallbackSearch uses PostgreSQL full-text search as fallback
func (s *SearchService) fallbackSearch(ctx context.Context, req *SearchRequest) (*SearchResponse, error) <span class="cov0" title="0">{
        limit := req.Limit
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">tasks, err := s.taskRepo.Search(ctx, req.ProjectID, req.Query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;SearchResponse{
                Results: tasks,
                Total:   int64(len(tasks)),
                Query:   req.Query,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/parser"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
)

// TaskService handles task business logic
type TaskService struct {
        repo   *repository.TaskRepository
        parser *parser.MarkdownParser
}

// NewTaskService creates a new task service
func NewTaskService(repo *repository.TaskRepository) *TaskService <span class="cov0" title="0">{
        return &amp;TaskService{
                repo:   repo,
                parser: parser.NewMarkdownParser(),
        }
}</span>

// CreateTaskRequest represents a request to create a task
type CreateTaskRequest struct {
        MarkdownBody string `json:"markdown_body"`
        CreatedBy    string `json:"created_by,omitempty"`
}

// UpdateTaskRequest represents a request to update a task
type UpdateTaskRequest struct {
        MarkdownBody string `json:"markdown_body"`
        UpdatedBy    string `json:"updated_by,omitempty"`
}

// Create creates a new task from markdown
func (s *TaskService) Create(ctx context.Context, projectID string, req *CreateTaskRequest) (*models.Task, error) <span class="cov0" title="0">{
        // Parse markdown
        parsed, err := s.parser.Parse(req.MarkdownBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse markdown: %w", err)
        }</span>

        // Convert to task model
        <span class="cov0" title="0">task, err := parsed.ToTask(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert to task: %w", err)
        }</span>

        // Set metadata
        <span class="cov0" title="0">task.CreatedBy = &amp;req.CreatedBy
        task.UpdatedBy = &amp;req.CreatedBy
        task.CreatedAt = time.Now()
        task.UpdatedAt = time.Now()

        // Create in repository
        if err := s.repo.Create(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

// GetByID retrieves a task by ID
func (s *TaskService) GetByID(ctx context.Context, projectID, taskID string) (*models.Task, error) <span class="cov0" title="0">{
        task, err := s.repo.GetByID(ctx, projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

// List retrieves all tasks for a project
func (s *TaskService) List(ctx context.Context, projectID string, filters *repository.TaskFilters) ([]*models.Task, error) <span class="cov0" title="0">{
        tasks, err := s.repo.List(ctx, projectID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// Update updates an existing task
func (s *TaskService) Update(ctx context.Context, projectID, taskID string, req *UpdateTaskRequest) (*models.Task, error) <span class="cov0" title="0">{
        // Get existing task
        existingTask, err := s.repo.GetByID(ctx, projectID, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse new markdown
        <span class="cov0" title="0">parsed, err := s.parser.Parse(req.MarkdownBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse markdown: %w", err)
        }</span>

        // Convert to task model
        <span class="cov0" title="0">updatedTask, err := parsed.ToTask(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert to task: %w", err)
        }</span>

        // Verify ID hasn't changed
        <span class="cov0" title="0">if updatedTask.ID != taskID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task ID cannot be changed")
        }</span>

        // Preserve timestamps
        <span class="cov0" title="0">updatedTask.CreatedAt = existingTask.CreatedAt
        updatedTask.CreatedBy = existingTask.CreatedBy
        updatedTask.UpdatedBy = &amp;req.UpdatedBy

        // Update status-specific timestamps
        if updatedTask.Status == models.TaskStatusDone &amp;&amp; existingTask.Status != models.TaskStatusDone </span><span class="cov0" title="0">{
                now := time.Now()
                updatedTask.CompletedAt = &amp;now
        }</span>

        // Update in repository
        <span class="cov0" title="0">if err := s.repo.Update(ctx, updatedTask); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">return updatedTask, nil</span>
}

// Delete deletes a task
func (s *TaskService) Delete(ctx context.Context, projectID, taskID string) error <span class="cov0" title="0">{
        return s.repo.Delete(ctx, projectID, taskID)
}</span>

// Search performs full-text search
func (s *TaskService) Search(ctx context.Context, projectID, query string, limit int) ([]*models.Task, error) <span class="cov0" title="0">{
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov0" title="0">return s.repo.Search(ctx, projectID, query, limit)</span>
}

// GetAcceptanceCriteria extracts acceptance criteria from a task
func (s *TaskService) GetAcceptanceCriteria(task *models.Task) []string <span class="cov0" title="0">{
        return parser.ExtractAcceptanceCriteria(task.MarkdownBody)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/tktomaru/taskai/taskai-server/internal/models"
        "github.com/tktomaru/taskai/taskai-server/internal/query"
        "github.com/tktomaru/taskai/taskai-server/internal/repository"
)

// ViewService handles saved view business logic
type ViewService struct {
        repo       *repository.ViewRepository
        parser     *query.QueryParser
        sqlBuilder *query.SQLBuilder
}

// NewViewService creates a new view service
func NewViewService(repo *repository.ViewRepository) *ViewService <span class="cov0" title="0">{
        return &amp;ViewService{
                repo:       repo,
                parser:     query.NewQueryParser(),
                sqlBuilder: query.NewSQLBuilder(),
        }
}</span>

// CreateViewRequest represents a request to create a view
type CreateViewRequest struct {
        ID          string           `json:"id"`
        Name        string           `json:"name"`
        Description string           `json:"description"`
        Scope       models.ViewScope `json:"scope"`
        RawQuery    string           `json:"raw_query"`
        OwnerUserID string           `json:"owner_user_id,omitempty"`
}

// UpdateViewRequest represents a request to update a view
type UpdateViewRequest struct {
        Name        string           `json:"name"`
        Description string           `json:"description"`
        Scope       models.ViewScope `json:"scope"`
        RawQuery    string           `json:"raw_query"`
}

// Create creates a new saved view
func (s *ViewService) Create(ctx context.Context, projectID string, req *CreateViewRequest) (*models.SavedView, error) <span class="cov0" title="0">{
        if req.ID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view ID is required")
        }</span>

        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view name is required")
        }</span>

        // Parse and normalize query
        <span class="cov0" title="0">parsed, err := s.parser.Parse(req.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: %w", err)
        }</span>

        // Normalize query (for stable comparison)
        <span class="cov0" title="0">normalizedQuery := s.normalizeQuery(parsed)

        // Build presentation settings
        presentation := make(models.JSONB)
        if parsed.Sort != nil </span><span class="cov0" title="0">{
                presentation["sort"] = parsed.Sort.Field + "_" + parsed.Sort.Order
        }</span>
        <span class="cov0" title="0">if parsed.Group != nil </span><span class="cov0" title="0">{
                presentation["group"] = parsed.Group.Field
        }</span>
        <span class="cov0" title="0">if parsed.Limit &gt; 0 </span><span class="cov0" title="0">{
                presentation["limit"] = parsed.Limit
        }</span>
        <span class="cov0" title="0">if len(parsed.Columns) &gt; 0 </span><span class="cov0" title="0">{
                presentation["cols"] = parsed.Columns
        }</span>
        <span class="cov0" title="0">if parsed.ViewType != "" </span><span class="cov0" title="0">{
                presentation["view"] = parsed.ViewType
        }</span>

        <span class="cov0" title="0">view := &amp;models.SavedView{
                ID:              req.ID,
                ProjectID:       projectID,
                OwnerUserID:     &amp;req.OwnerUserID,
                Name:            req.Name,
                Description:     &amp;req.Description,
                Scope:           req.Scope,
                RawQuery:        req.RawQuery,
                NormalizedQuery: normalizedQuery,
                Presentation:    presentation,
                UseCount:        0,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        if err := s.repo.Create(ctx, view); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return view, nil</span>
}

// GetByID retrieves a view by ID
func (s *ViewService) GetByID(ctx context.Context, projectID, viewID string) (*models.SavedView, error) <span class="cov0" title="0">{
        return s.repo.GetByID(ctx, projectID, viewID)
}</span>

// List retrieves all views for a project
func (s *ViewService) List(ctx context.Context, projectID string, ownerUserID *string) ([]*models.SavedView, error) <span class="cov0" title="0">{
        return s.repo.List(ctx, projectID, ownerUserID)
}</span>

// Update updates an existing view
func (s *ViewService) Update(ctx context.Context, projectID, viewID string, req *UpdateViewRequest) (*models.SavedView, error) <span class="cov0" title="0">{
        // Get existing view
        view, err := s.repo.GetByID(ctx, projectID, viewID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse and normalize new query
        <span class="cov0" title="0">parsed, err := s.parser.Parse(req.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: %w", err)
        }</span>

        <span class="cov0" title="0">normalizedQuery := s.normalizeQuery(parsed)

        // Update fields
        view.Name = req.Name
        view.Description = &amp;req.Description
        view.Scope = req.Scope
        view.RawQuery = req.RawQuery
        view.NormalizedQuery = normalizedQuery

        // Update presentation
        presentation := make(models.JSONB)
        if parsed.Sort != nil </span><span class="cov0" title="0">{
                presentation["sort"] = parsed.Sort.Field + "_" + parsed.Sort.Order
        }</span>
        <span class="cov0" title="0">if parsed.Group != nil </span><span class="cov0" title="0">{
                presentation["group"] = parsed.Group.Field
        }</span>
        <span class="cov0" title="0">if parsed.Limit &gt; 0 </span><span class="cov0" title="0">{
                presentation["limit"] = parsed.Limit
        }</span>
        <span class="cov0" title="0">if len(parsed.Columns) &gt; 0 </span><span class="cov0" title="0">{
                presentation["cols"] = parsed.Columns
        }</span>
        <span class="cov0" title="0">if parsed.ViewType != "" </span><span class="cov0" title="0">{
                presentation["view"] = parsed.ViewType
        }</span>
        <span class="cov0" title="0">view.Presentation = presentation

        if err := s.repo.Update(ctx, view); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return view, nil</span>
}

// Delete deletes a view
func (s *ViewService) Delete(ctx context.Context, projectID, viewID string) error <span class="cov0" title="0">{
        return s.repo.Delete(ctx, projectID, viewID)
}</span>

// Execute executes a saved view's query
func (s *ViewService) Execute(ctx context.Context, projectID, viewID string) ([]*models.Task, error) <span class="cov0" title="0">{
        // Get view
        view, err := s.repo.GetByID(ctx, projectID, viewID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse query
        <span class="cov0" title="0">parsed, err := s.parser.Parse(view.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse query: %w", err)
        }</span>

        // Build SQL
        <span class="cov0" title="0">buildResult, err := s.sqlBuilder.Build(projectID, parsed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build SQL: %w", err)
        }</span>

        // Execute query
        <span class="cov0" title="0">tasks, err := s.repo.ExecuteQuery(ctx, buildResult.SQL, buildResult.Args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Increment use count (async)
        <span class="cov0" title="0">go s.repo.IncrementUseCount(context.Background(), viewID)

        return tasks, nil</span>
}

// normalizeQuery generates a normalized query string for stable comparison
func (s *ViewService) normalizeQuery(parsed *query.ParsedQuery) string <span class="cov0" title="0">{
        // Simple normalization: reconstruct query in canonical form
        // For now, just return the filters in a consistent order
        var parts []string

        for _, filter := range parsed.Filters </span><span class="cov0" title="0">{
                part := filter.Key + ":" + fmt.Sprint(filter.Value)
                if filter.Negate </span><span class="cov0" title="0">{
                        part = "-" + part
                }</span>
                <span class="cov0" title="0">parts = append(parts, part)</span>
        }

        <span class="cov0" title="0">return fmt.Sprint(parts)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package websocket

import (
        "log"
        "time"

        "github.com/gorilla/websocket"
)

const (
        // Time allowed to write a message to the peer
        writeWait = 10 * time.Second

        // Time allowed to read the next pong message from the peer
        pongWait = 60 * time.Second

        // Send pings to peer with this period (must be less than pongWait)
        pingPeriod = (pongWait * 9) / 10

        // Maximum message size allowed from peer
        maxMessageSize = 512
)

// Client represents a WebSocket client connection
type Client struct {
        // The WebSocket hub
        hub *Hub

        // The WebSocket connection
        conn *websocket.Conn

        // Buffered channel of outbound messages
        send chan []byte

        // Project ID this client is subscribed to
        ProjectID string

        // User ID (optional, for future use)
        UserID string
}

// NewClient creates a new WebSocket client
func NewClient(hub *Hub, conn *websocket.Conn, projectID string, userID string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                hub:       hub,
                conn:      conn,
                send:      make(chan []byte, 256),
                ProjectID: projectID,
                UserID:    userID,
        }
}</span>

// readPump pumps messages from the WebSocket connection to the hub
func (c *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.Unregister &lt;- c
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">c.conn.SetReadLimit(maxMessageSize)
        c.conn.SetReadDeadline(time.Now().Add(pongWait))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(pongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                // We don't process incoming messages from clients for now
                // This is a broadcast-only WebSocket
        }
}

// writePump pumps messages from the hub to the WebSocket connection
func (c *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.send:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                // The hub closed the channel
                                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Add queued messages to the current WebSocket message
                        n := len(c.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Start starts the client's read and write pumps
func (c *Client) Start() <span class="cov0" title="0">{
        go c.writePump()
        go c.readPump()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package websocket

import (
        "encoding/json"
        "log"
        "sync"
)

// EventType represents the type of WebSocket event
type EventType string

const (
        EventTaskCreated EventType = "task.created"
        EventTaskUpdated EventType = "task.updated"
        EventTaskDeleted EventType = "task.deleted"
        EventProjectUpdated EventType = "project.updated"
)

// Message represents a WebSocket message
type Message struct {
        Type      EventType   `json:"type"`
        ProjectID string      `json:"project_id,omitempty"`
        TaskID    string      `json:"task_id,omitempty"`
        Data      interface{} `json:"data,omitempty"`
}

// Hub maintains the set of active clients and broadcasts messages to them
type Hub struct {
        // Registered clients by project ID
        clients map[string]map[*Client]bool

        // Register requests from clients
        Register chan *Client

        // Unregister requests from clients
        Unregister chan *Client

        // Broadcast messages to clients (internal use)
        broadcast chan *Message

        // Mutex for thread-safe access
        mu sync.RWMutex
}

// NewHub creates a new WebSocket hub
func NewHub() *Hub <span class="cov7" title="8">{
        return &amp;Hub{
                clients:    make(map[string]map[*Client]bool),
                Register:   make(chan *Client),
                Unregister: make(chan *Client),
                broadcast:  make(chan *Message, 256),
        }
}</span>

// Run starts the hub's main loop
func (h *Hub) Run() <span class="cov3" title="2">{
        for </span><span class="cov8" title="13">{
                select </span>{
                case client := &lt;-h.Register:<span class="cov7" title="10">
                        h.registerClient(client)</span>

                case client := &lt;-h.Unregister:<span class="cov0" title="0">
                        h.unregisterClient(client)</span>

                case message := &lt;-h.broadcast:<span class="cov1" title="1">
                        h.broadcastMessage(message)</span>
                }
        }
}

// registerClient registers a new client
func (h *Hub) registerClient(client *Client) <span class="cov10" title="22">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.clients[client.ProjectID] == nil </span><span class="cov7" title="8">{
                h.clients[client.ProjectID] = make(map[*Client]bool)
        }</span>
        <span class="cov10" title="22">h.clients[client.ProjectID][client] = true

        log.Printf("Client registered for project %s (total: %d)", client.ProjectID, len(h.clients[client.ProjectID]))</span>
}

// unregisterClient unregisters a client
func (h *Hub) unregisterClient(client *Client) <span class="cov1" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if clients, ok := h.clients[client.ProjectID]; ok </span><span class="cov1" title="1">{
                if _, ok := clients[client]; ok </span><span class="cov1" title="1">{
                        delete(clients, client)
                        close(client.send)

                        if len(clients) == 0 </span><span class="cov1" title="1">{
                                delete(h.clients, client.ProjectID)
                        }</span>

                        <span class="cov1" title="1">log.Printf("Client unregistered from project %s (remaining: %d)", client.ProjectID, len(clients))</span>
                }
        }
}

// broadcastMessage broadcasts a message to all clients in the project
func (h *Hub) broadcastMessage(message *Message) <span class="cov4" title="3">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        projectClients := h.clients[message.ProjectID]
        if projectClients == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert message to JSON once
        <span class="cov4" title="3">data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error marshaling message: %v", err)
                return
        }</span>

        // Send to all clients in the project
        <span class="cov4" title="3">for client := range projectClients </span><span class="cov5" title="4">{
                select </span>{
                case client.send &lt;- data:<span class="cov5" title="4"></span>
                default:<span class="cov0" title="0">
                        // Client's send channel is full, close it
                        close(client.send)
                        delete(projectClients, client)</span>
                }
        }

        <span class="cov4" title="3">if len(projectClients) == 0 </span><span class="cov0" title="0">{
                delete(h.clients, message.ProjectID)
        }</span>
}

// Broadcast sends a message to all clients in a project
func (h *Hub) Broadcast(eventType EventType, projectID string, taskID string, data interface{}) <span class="cov1" title="1">{
        message := &amp;Message{
                Type:      eventType,
                ProjectID: projectID,
                TaskID:    taskID,
                Data:      data,
        }

        select </span>{
        case h.broadcast &lt;- message:<span class="cov1" title="1"></span>
        default:<span class="cov0" title="0">
                log.Printf("Broadcast channel full, dropping message")</span>
        }
}

// GetClientCount returns the number of connected clients for a project
func (h *Hub) GetClientCount(projectID string) int <span class="cov6" title="6">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        if clients, ok := h.clients[projectID]; ok </span><span class="cov4" title="3">{
                return len(clients)
        }</span>
        <span class="cov4" title="3">return 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
